/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		;
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(requestTimeout) { // eslint-disable-line no-unused-vars
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if(typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch(err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if(request.readyState !== 4) return;
/******/ 				if(request.status === 0) {
/******/ 					// timeout
/******/ 					reject(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 				} else if(request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if(request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch(e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "5217a5a103cd69b30da9"; // eslint-disable-line no-unused-vars
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if(me.children.indexOf(request) < 0)
/******/ 					me.children.push(request);
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name) && name !== "e") {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/ 	
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if(hotStatus === "prepare") {
/******/ 					if(!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if(!deferred) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve().then(function() {
/******/ 				return hotApply(hotApplyOnUpdate);
/******/ 			}).then(
/******/ 				function(result) {
/******/ 					deferred.resolve(result);
/******/ 				},
/******/ 				function(err) {
/******/ 					deferred.reject(err);
/******/ 				}
/******/ 			);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 	
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/ 	
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while(queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if(module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(!parent) continue;
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 	
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn("[HMR] unexpected require(" + result.moduleId + ") to disposed module");
/******/ 		};
/******/ 	
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				var result;
/******/ 				if(hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if(result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch(result.type) {
/******/ 					case "self-declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if(options.onUnaccepted)
/******/ 							options.onUnaccepted(result);
/******/ 						if(!options.ignoreUnaccepted)
/******/ 							abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if(options.onAccepted)
/******/ 							options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if(options.onDisposed)
/******/ 							options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if(abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if(doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for(moduleId in result.outdatedDependencies) {
/******/ 						if(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {
/******/ 							if(!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if(doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if(hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/ 	
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for(j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if(idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for(i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if(cb) {
/******/ 							if(callbacks.indexOf(cb) >= 0) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for(i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch(err) {
/******/ 							if(options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if(!options.ignoreErrored) {
/******/ 								if(!error)
/******/ 									error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err2) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								orginalError: err, // TODO remove in webpack 4
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err2;
/******/ 						}
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if(options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if(!options.ignoreErrored) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire("./src/main.js")(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/app.vue":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {};

/***/ }),

/***/ "./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-5ef48958\",\"scoped\":false,\"sourceMap\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/app.vue":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, "\nhtml, body {\n    width: 100%;\n    height: 100%;\n}\n.app {\n    height: 100%;\n    width: 100%;\n}\n", "", {"version":3,"sources":["/home/wjh/桌面/vueDemo/src/src/app.vue"],"names":[],"mappings":";AACA;AACA,gBAAA;AACA,iBAAA;CACA;AACA;AACA,iBAAA;AACA,gBAAA;CACA","file":"app.vue","sourcesContent":["<style>\nhtml, body {\n    width: 100%;\n    height: 100%;\n}\n.app {\n    height: 100%;\n    width: 100%;\n}\n</style>\n<template>\n    <div class=\"app\">\n        <router-view>\n\n        </router-view>\n    </div>\n</template>\n\n<script>\nexport default {\n    \n}\n</script>"],"sourceRoot":""}]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),

/***/ "./node_modules/process/browser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__("./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmeidate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || undefined && undefined.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || undefined && undefined.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/vue-hot-reload-api/dist/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vue; // late bind
var version;
var map = window.__VUE_HOT_MAP__ = Object.create(null);
var installed = false;
var isBrowserify = false;
var initHookName = 'beforeCreate';

exports.install = function (vue, browserify) {
  if (installed) {
    return;
  }
  installed = true;

  Vue = vue.__esModule ? vue.default : vue;
  version = Vue.version.split('.').map(Number);
  isBrowserify = browserify;

  // compat with < 2.0.0-alpha.7
  if (Vue.config._lifecycleHooks.indexOf('init') > -1) {
    initHookName = 'init';
  }

  exports.compatible = version[0] >= 2;
  if (!exports.compatible) {
    console.warn('[HMR] You are using a version of vue-hot-reload-api that is ' + 'only compatible with Vue.js core ^2.0.0.');
    return;
  }
};

/**
 * Create a record for a hot module, which keeps track of its constructor
 * and instances
 *
 * @param {String} id
 * @param {Object} options
 */

exports.createRecord = function (id, options) {
  if (map[id]) {
    return;
  }

  var Ctor = null;
  if (typeof options === 'function') {
    Ctor = options;
    options = Ctor.options;
  }
  makeOptionsHot(id, options);
  map[id] = {
    Ctor: Ctor,
    options: options,
    instances: []
  };
};

/**
 * Check if module is recorded
 *
 * @param {String} id
 */

exports.isRecorded = function (id) {
  return typeof map[id] !== 'undefined';
};

/**
 * Make a Component options object hot.
 *
 * @param {String} id
 * @param {Object} options
 */

function makeOptionsHot(id, options) {
  if (options.functional) {
    var render = options.render;
    options.render = function (h, ctx) {
      var instances = map[id].instances;
      if (ctx && instances.indexOf(ctx.parent) < 0) {
        instances.push(ctx.parent);
      }
      return render(h, ctx);
    };
  } else {
    injectHook(options, initHookName, function () {
      var record = map[id];
      if (!record.Ctor) {
        record.Ctor = this.constructor;
      }
      record.instances.push(this);
    });
    injectHook(options, 'beforeDestroy', function () {
      var instances = map[id].instances;
      instances.splice(instances.indexOf(this), 1);
    });
  }
}

/**
 * Inject a hook to a hot reloadable component so that
 * we can keep track of it.
 *
 * @param {Object} options
 * @param {String} name
 * @param {Function} hook
 */

function injectHook(options, name, hook) {
  var existing = options[name];
  options[name] = existing ? Array.isArray(existing) ? existing.concat(hook) : [existing, hook] : [hook];
}

function tryWrap(fn) {
  return function (id, arg) {
    try {
      fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn('Something went wrong during Vue component hot-reload. Full reload required.');
    }
  };
}

function updateOptions(oldOptions, newOptions) {
  for (var key in oldOptions) {
    if (!(key in newOptions)) {
      delete oldOptions[key];
    }
  }
  for (var key$1 in newOptions) {
    oldOptions[key$1] = newOptions[key$1];
  }
}

exports.rerender = tryWrap(function (id, options) {
  var record = map[id];
  if (!options) {
    record.instances.slice().forEach(function (instance) {
      instance.$forceUpdate();
    });
    return;
  }
  if (typeof options === 'function') {
    options = options.options;
  }
  if (record.Ctor) {
    record.Ctor.options.render = options.render;
    record.Ctor.options.staticRenderFns = options.staticRenderFns;
    record.instances.slice().forEach(function (instance) {
      instance.$options.render = options.render;
      instance.$options.staticRenderFns = options.staticRenderFns;
      // reset static trees
      // pre 2.5, all static trees are cahced together on the instance
      if (instance._staticTrees) {
        instance._staticTrees = [];
      }
      // 2.5.0
      if (Array.isArray(record.Ctor.options.cached)) {
        record.Ctor.options.cached = [];
      }
      // 2.5.3
      if (Array.isArray(instance.$options.cached)) {
        instance.$options.cached = [];
      }
      // post 2.5.4: v-once trees are cached on instance._staticTrees.
      // Pure static trees are cached on the staticRenderFns array
      // (both already reset above)
      instance.$forceUpdate();
    });
  } else {
    // functional or no instance created yet
    record.options.render = options.render;
    record.options.staticRenderFns = options.staticRenderFns;

    // handle functional component re-render
    if (record.options.functional) {
      // rerender with full options
      if (Object.keys(options).length > 2) {
        updateOptions(record.options, options);
      } else {
        // template-only rerender.
        // need to inject the style injection code for CSS modules
        // to work properly.
        var injectStyles = record.options._injectStyles;
        if (injectStyles) {
          var render = options.render;
          record.options.render = function (h, ctx) {
            injectStyles.call(ctx);
            return render(h, ctx);
          };
        }
      }
      record.options._Ctor = null;
      // 2.5.3
      if (Array.isArray(record.options.cached)) {
        record.options.cached = [];
      }
      record.instances.slice().forEach(function (instance) {
        instance.$forceUpdate();
      });
    }
  }
});

exports.reload = tryWrap(function (id, options) {
  var record = map[id];
  if (options) {
    if (typeof options === 'function') {
      options = options.options;
    }
    makeOptionsHot(id, options);
    if (record.Ctor) {
      if (version[1] < 2) {
        // preserve pre 2.2 behavior for global mixin handling
        record.Ctor.extendOptions = options;
      }
      var newCtor = record.Ctor.super.extend(options);
      record.Ctor.options = newCtor.options;
      record.Ctor.cid = newCtor.cid;
      record.Ctor.prototype = newCtor.prototype;
      if (newCtor.release) {
        // temporary global mixin strategy used in < 2.0.0-alpha.6
        newCtor.release();
      }
    } else {
      updateOptions(record.options, options);
    }
  }
  record.instances.slice().forEach(function (instance) {
    if (instance.$vnode && instance.$vnode.context) {
      instance.$vnode.context.$forceUpdate();
    } else {
      console.warn('Root or manually mounted instance modified. Full reload required.');
    }
  });
});

/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/component-normalizer.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = normalizeComponent;
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  scriptExports = scriptExports || {}

  // ES6 modules interop
  var type = typeof scriptExports.default
  if (type === 'object' || type === 'function') {
    scriptExports = scriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-5ef48958\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/app.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "app" }, [_c("router-view")], 1)
}
var staticRenderFns = []
render._withStripped = true

if (true) {
  module.hot.accept()
  if (module.hot.data) {
    __webpack_require__("./node_modules/vue-hot-reload-api/dist/index.js")      .rerender("data-v-5ef48958", { render: render, staticRenderFns: staticRenderFns })
  }
}

/***/ }),

/***/ "./node_modules/vue-router/dist/vue-router.esm.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
  * vue-router v3.0.1
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if (process.env.NODE_ENV !== 'production' && !condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

function isError(err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1;
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent && parent._routerRoot !== parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name];

    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (val && current !== vm || !val && current === vm) {
        matched.instances[name] = val;
      }
    }

    // also register instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // resolve props
    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);
    if (propsToPass) {
      // clone to prevent mutation
      propsToPass = data.props = extend({}, propsToPass);
      // pass non-declared props as attrs
      var attrs = data.attrs = data.attrs || {};
      for (var key in propsToPass) {
        if (!component.props || !(key in component.props)) {
          attrs[key] = propsToPass[key];
          delete propsToPass[key];
        }
      }
    }

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config === 'undefined' ? 'undefined' : _typeof(config)) {
    case 'undefined':
      return;
    case 'object':
      return config;
    case 'function':
      return config(route);
    case 'boolean':
      return config ? route.params : undefined;
    default:
      if (process.env.NODE_ENV !== 'production') {
        warn(false, "props in \"" + route.path + "\" is a " + (typeof config === 'undefined' ? 'undefined' : _typeof(config)) + ", " + "expecting an object, function or boolean.");
      }
  }
}

function extend(to, from) {
  for (var key in from) {
    to[key] = from[key];
  }
  return to;
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function encodeReserveReplacer(c) {
  return '%' + c.charCodeAt(0).toString(16);
};
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function encode(str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery, _parseQuery) {
  if (extraQuery === void 0) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || '');
  } catch (e) {
    process.env.NODE_ENV !== 'production' && warn(false, e.message);
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    parsedQuery[key] = extraQuery[key];
  }
  return parsedQuery;
}

function parseQuery(query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom, router) {
  var stringifyQuery$$1 = router && router.options.stringifyQuery;

  var query = location.query || {};
  try {
    query = clone(query);
  } catch (e) {}

  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery$$1),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
  }
  return Object.freeze(route);
}

function clone(value) {
  if (Array.isArray(value)) {
    return value.map(clone);
  } else if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
    var res = {};
    for (var key in value) {
      res[key] = clone(value[key]);
    }
    return res;
  } else {
    return value;
  }
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res;
}

function getFullPath(ref, _stringifyQuery) {
  var path = ref.path;
  var query = ref.query;if (query === void 0) query = {};
  var hash = ref.hash;if (hash === void 0) hash = '';

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {};

  // handle null value #1566
  if (!a || !b) {
    return a === b;
  }
  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key];
    // check nested equality
    if ((typeof aVal === 'undefined' ? 'undefined' : _typeof(aVal)) === 'object' && (typeof bVal === 'undefined' ? 'undefined' : _typeof(bVal)) === 'object') {
      return isObjectEqual(aVal, bVal);
    }
    return String(aVal) === String(bVal);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }
  return true;
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;
    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;
    var compareTarget = location.path ? createRoute(null, location, null, router) : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);

    var handler = function handler(e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {
    return;
  }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) {
    return;
  }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) {
    return;
  }
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) {
      return;
    }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true;
}

function findAnchor(children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child;
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed && _Vue === Vue) {
    return;
  }
  install.installed = true;

  _Vue = Vue;

  var isDef = function isDef(v) {
    return v !== undefined;
  };

  var registerInstance = function registerInstance(vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = this.$parent && this.$parent._routerRoot || this;
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed() {
      registerInstance(this);
    }
  });

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this._routerRoot._router;
    }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this._routerRoot._route;
    }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath(relative, base, append) {
  var firstChar = relative.charAt(0);
  if (firstChar === '/') {
    return relative;
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative;
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (_typeof(tokens[i]) === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (isarray(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

/*  */

// $flow-disable-line
var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = pathToRegexp_1.compile(path));
    return filler(params || {}, { pretty: true });
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }
    return '';
  }
}

/*  */

function createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  // $flow-disable-line
  var pathMap = oldPathMap || Object.create(null);
  // $flow-disable-line
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;
  if (process.env.NODE_ENV !== 'production') {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var pathToRegexpOptions = route.pathToRegexpOptions || {};
  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (process.env.NODE_ENV !== 'production') {
      if (route.name && !route.redirect && route.children.some(function (child) {
        return (/^\/?$/.test(child.path)
        );
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];

    aliases.forEach(function (alias) {
      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs
      );
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function compileRouteRegex(path, pathToRegexpOptions) {
  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);
  if (process.env.NODE_ENV !== 'production') {
    var keys = Object.create(null);
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], "Duplicate param keys in route with path: \"" + path + "\"");
      keys[key.name] = true;
    });
  }
  return regex;
}

function normalizePath(path, parent, strict) {
  if (!strict) {
    path = path.replace(/\/$/, '');
  }
  if (path[0] === '/') {
    return path;
  }
  if (parent == null) {
    return path;
  }
  return cleanPath(parent.path + "/" + path);
}

/*  */

function normalizeLocation(raw, current, append, router) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next;
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if (process.env.NODE_ENV !== 'production') {
      warn(false, "relative params navigation requires a current route.");
    }
    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;

  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);

  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}

function assign(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a;
}

/*  */

function createMatcher(routes, router) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        warn(record, "Route with name '" + name + "' does not exist");
      }
      if (!record) {
        return _createRoute(null, location);
      }
      var paramNames = record.regex.keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (_typeof(location.params) !== 'object') {
        location.params = {};
      }

      if (currentRoute && _typeof(currentRoute.params) === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom);
        }
      }
    }
    // no match
    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || (typeof redirect === 'undefined' ? 'undefined' : _typeof(redirect)) !== 'object') {
      if (process.env.NODE_ENV !== 'production') {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\"");
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      if (process.env.NODE_ENV !== 'production') {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }
    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }
    return createRoute(record, location, redirectedFrom, router);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(regex, path, params) {
  var m = path.match(regex);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}

/*  */

var positionStore = Object.create(null);

function setupScroll() {
  // Fix for #1585 for Firefox
  window.history.replaceState({ key: getStateKey() }, '');
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);

    if (!shouldScroll) {
      return;
    }

    if (typeof shouldScroll.then === 'function') {
      shouldScroll.then(function (shouldScroll) {
        scrollToPosition(shouldScroll, position);
      }).catch(function (err) {
        if (process.env.NODE_ENV !== 'production') {
          assert(false, err.toString());
        }
      });
    } else {
      scrollToPosition(shouldScroll, position);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();
  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function normalizeOffset(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

function scrollToPosition(shouldScroll, position) {
  var isObject = (typeof shouldScroll === 'undefined' ? 'undefined' : _typeof(shouldScroll)) === 'object';
  if (isObject && typeof shouldScroll.selector === 'string') {
    var el = document.querySelector(shouldScroll.selector);
    if (el) {
      var offset = shouldScroll.offset && _typeof(shouldScroll.offset) === 'object' ? shouldScroll.offset : {};
      offset = normalizeOffset(offset);
      position = getElementPosition(el, offset);
    } else if (isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }
  } else if (isObject && isValidPosition(shouldScroll)) {
    position = normalizePosition(shouldScroll);
  }

  if (position) {
    window.scrollTo(position.x, position.y);
  }
}

/*  */

var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}

/*  */

function runQueue(queue, fn, cb) {
  var step = function step(index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

function resolveAsyncComponents(matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default;
          }
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending <= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
          process.env.NODE_ENV !== 'production' && warn(false, msg);
          if (!error) {
            error = isError(reason) ? reason : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) {
      next();
    }
  };
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

var hasSymbol = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';

function isESModule(obj) {
  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === 'Module';
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once(fn) {
  var called = false;
  return function () {
    var args = [],
        len = arguments.length;
    while (len--) {
      args[len] = arguments[len];
    }if (called) {
      return;
    }
    called = true;
    return fn.apply(this, args);
  };
}

/*  */

var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError(errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }
    if (err && !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) {
        cb(err);
      });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;

  var current = this.current;
  var abort = function abort(err) {
    if (isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }
    onAbort && onAbort(err);
  };
  if (isSameRoute(route, current) &&
  // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;

  var queue = [].concat(
  // in-component leave guards
  extractLeaveGuards(deactivated),
  // global before hooks
  this.router.beforeHooks,
  // in-component update hooks
  extractUpdateHooks(updated),
  // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }),
  // async components
  resolveAsyncComponents(activated));

  this.pending = route;
  var iterator = function iterator(hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }
    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (typeof to === 'string' || (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();
          if ((typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function isValid() {
      return this$1.current === route;
    };
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/';
      // strip full URL origin
      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  if (instance) {
    return function boundRouteGuard() {
      return guard.apply(instance, arguments);
    };
  }
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

/*  */

var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    var initLocation = getLocation(this.base);
    window.addEventListener('popstate', function (e) {
      var current = this$1.current;

      // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.
      var location = getLocation(this$1.base);
      if (this$1.current === START && location === initLocation) {
        return;
      }

      this$1.transitionTo(location, function (route) {
        if (expectScroll) {
          handleScroll(router, route, current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash;
}

/*  */

var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return;
    }
    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      setupScroll();
    }

    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {
      var current = this$1.current;
      if (!ensureSlash()) {
        return;
      }
      this$1.transitionTo(getHash(), function (route) {
        if (supportsScroll) {
          handleScroll(this$1.router, route, current, true);
        }
        if (!supportsPushState) {
          replaceHash(route.fullPath);
        }
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true;
  }
  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1);
}

function getUrl(path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  return base + "#" + path;
}

function pushHash(path) {
  if (supportsPushState) {
    pushState(getUrl(path));
  } else {
    window.location.hash = path;
  }
}

function replaceHash(path) {
  if (supportsPushState) {
    replaceState(getUrl(path));
  } else {
    window.location.replace(getUrl(path));
  }
}

/*  */

var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {
    // noop
  };

  return AbstractHistory;
}(History);

/*  */

var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;
    default:
      if (process.env.NODE_ENV !== 'production') {
        assert(false, "invalid mode: " + mode);
      }
  }
};

var prototypeAccessors = { currentRoute: { configurable: true } };

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app /* Vue component instance */) {
  var this$1 = this;

  process.env.NODE_ENV !== 'production' && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return;
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function setupHashListener() {
      history.setupListeners();
    };
    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  return registerHook(this.beforeHooks, fn);
};

VueRouter.prototype.beforeResolve = function beforeResolve(fn) {
  return registerHook(this.resolveHooks, fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  return registerHook(this.afterHooks, fn);
};

VueRouter.prototype.onReady = function onReady(cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError(errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;
  if (!route) {
    return [];
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append, this);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function registerHook(list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i > -1) {
      list.splice(i, 1);
    }
  };
}

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '3.0.1';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

exports.default = VueRouter;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-5ef48958\",\"scoped\":false,\"sourceMap\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/app.vue":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-5ef48958\",\"scoped\":false,\"sourceMap\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/app.vue");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__("./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("6298147a", content, false, {});
// Hot Module Replacement
if(true) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-5ef48958\",\"scoped\":false,\"sourceMap\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/app.vue", function() {
     var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-5ef48958\",\"scoped\":false,\"sourceMap\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/app.vue");
     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./node_modules/vue-style-loader/lib/addStylesClient.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = addStylesClient;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__listToStyles__ = __webpack_require__("./node_modules/vue-style-loader/lib/listToStyles.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__listToStyles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__listToStyles__);
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = __WEBPACK_IMPORTED_MODULE_0__listToStyles___default()(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = __WEBPACK_IMPORTED_MODULE_0__listToStyles___default()(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ "./node_modules/vue-style-loader/lib/listToStyles.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = listToStyles;
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles(parentId, list) {
  var styles = [];
  var newStyles = {};
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    };
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] });
    } else {
      newStyles[id].parts.push(part);
    }
  }
  return styles;
}

/***/ }),

/***/ "./node_modules/vue/dist/vue.esm.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Vue.js v2.5.13
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}

/**
 * Check if value is primitive
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' ||
  // $flow-disable-line
  (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol' || typeof value === 'boolean';
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

/**
 * Get the raw type string of a value e.g. [object Object]
 */
var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});

/**
 * Simple bind, faster than native
 */
function bind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn;
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop(a, b, c) {}

/**
 * Always return false.
 */
var no = function no(a, b, c) {
  return false;
};

/**
 * Return same value
 */
var identity = function identity(_) {
  return _;
};

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  if (a === b) {
    return true;
  }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = ['component', 'directive', 'filter'];

var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: process.env.NODE_ENV !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: process.env.NODE_ENV !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};

/*  */

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = {}.watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function isServerRendering() {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check
var formatComponentName = noop;

if (process.env.NODE_ENV !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function classify(str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function warn(msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function tip(msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function formatComponentName(vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function repeat(str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) {
        res += str;
      }
      if (n > 1) {
        str += str;
      }
      n >>= 1;
    }
    return res;
  };

  generateComponentTrace = function generateComponentTrace(vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }
  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function createEmptyVNode(text) {
  if (text === void 0) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode, deep) {
  var componentOptions = vnode.componentOptions;
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.isCloned = true;
  if (deep) {
    if (vnode.children) {
      cloned.children = cloneVNodes(vnode.children, true);
    }
    if (componentOptions && componentOptions.children) {
      componentOptions.children = cloneVNodes(componentOptions.children, true);
    }
  }
  return cloned;
}

function cloneVNodes(vnodes, deep) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i], deep);
  }
  return res;
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;
    while (len--) {
      args[len] = arguments[len];
    }var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive(obj, key, val, customSetter, shallow) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (process.env.NODE_ENV !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);

      return parentVal;
    }
    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }
  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (process.env.NODE_ENV !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && process.env.NODE_ENV !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) {
    extend(ret, childVal);
  }
  return ret;
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function defaultStrat(parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!/^[a-zA-Z][\w-]*$/.test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options, vm) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  } else if (process.env.NODE_ENV !== 'production') {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject(options, vm) {
  var inject = options.inject;
  if (!inject) {
    return;
  }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
    }
  } else if (process.env.NODE_ENV !== 'production') {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (process.env.NODE_ENV !== 'production' &&
  // skip validation for weex recycle-list child component props
  !(false && isObject(value) && '@binding' in value)) {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn("Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ') + ", got " + toRawType(value) + ".", vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isType(type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type);
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true;
    }
  }
  /* istanbul ignore next */
  return false;
}

/*  */

function handleError(err, vm, info) {
  if (vm) {
    var cur = vm;
    while (cur = cur.$parent) {
      var hooks = cur.$options.errorCaptured;
      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;
            if (capture) {
              return;
            }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }
  globalHandleError(err, vm, info);
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }
  logError(err, vm, info);
}

function logError(err, vm, info) {
  if (process.env.NODE_ENV !== 'production') {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}

/*  */
/* globals MessageChannel */

var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using both micro and macro tasks.
// In < 2.4 we used micro tasks everywhere, but there are some scenarios where
// micro tasks have too high a priority and fires in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using macro tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use micro task by default, but expose a way to force macro task when
// needed (e.g. in event handlers attached by v-on).
var microTimerFunc;
var macroTimerFunc;
var useMacroTask = false;

// Determine (macro) Task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = function macroTimerFunc() {
    setImmediate(flushCallbacks);
  };
} else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) ||
// PhantomJS
MessageChannel.toString() === '[object MessageChannelConstructor]')) {
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = flushCallbacks;
  macroTimerFunc = function macroTimerFunc() {
    port.postMessage(1);
  };
} else {
  /* istanbul ignore next */
  macroTimerFunc = function macroTimerFunc() {
    setTimeout(flushCallbacks, 0);
  };
}

// Determine MicroTask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  microTimerFunc = function microTimerFunc() {
    p.then(flushCallbacks);
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) {
      setTimeout(noop);
    }
  };
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc;
}

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a Task instead of a MicroTask.
 */
function withMacroTask(fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true;
    var res = fn.apply(null, arguments);
    useMacroTask = false;
    return res;
  });
}

function nextTick(cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    if (useMacroTask) {
      macroTimerFunc();
    } else {
      microTimerFunc();
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}

/*  */

var mark;
var measure;

if (process.env.NODE_ENV !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function mark(tag) {
      return perf.mark(tag);
    };
    measure = function measure(name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (process.env.NODE_ENV !== 'production') {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function warnNonPresent(target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse(val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || Object.isFrozen(val)) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }
  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, def, cur, old, event;
  for (name in on) {
    def = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    /* istanbul ignore if */
    if (isUndef(cur)) {
      process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (process.env.NODE_ENV !== 'production') {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i);
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }
  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node;
}

function resolveAsyncComponent(factory, baseCtor, context) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function forceRender() {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(process.env.NODE_ENV !== 'production' ? "timeout (" + res.timeout + "ms)" : null);
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}

/*  */

function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}

/*  */

function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}

/*  */

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once) {
  if (once) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (!fn) {
      vm._events[event] = null;
      return vm;
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break;
        }
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (process.env.NODE_ENV !== 'production') {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, "event handler for \"" + event + "\"");
        }
      }
    }
    return vm;
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  var slots = {};
  if (!children) {
    return slots;
  }
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}

function resolveScopedSlots(fns, // see flow/vnode
res) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res;
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm);
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = function updateComponent() {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function updateComponent() {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data && parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (process.env.NODE_ENV !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function loop(key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) {
    loop(key);
  }observerState.shouldConvert = true;
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData(data, vm) {
  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }
  if (process.env.NODE_ENV !== 'production' && sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (process.env.NODE_ENV !== 'production') {
      if (methods[key] == null) {
        warn("Method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }
      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, keyOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        defineReactive(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {
        defineReactive(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
      /* istanbul ignore next */
      return Object.getOwnPropertyDescriptor(inject, key).enumerable;
    }) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break;
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if (process.env.NODE_ENV !== 'production') {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }
    return result;
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    ret._isVList = true;
  }
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes) {
      if (process.env.NODE_ENV !== 'production' && slotNodes._rendered) {
        warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      }
      slotNodes._rendered = true;
    }
    nodes = slotNodes || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes);
  } else {
    return nodes;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes(eventKeyCode, key, builtInAlias, eventKeyName) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (keyCodes) {
    if (Array.isArray(keyCodes)) {
      return keyCodes.indexOf(eventKeyCode) === -1;
    } else {
      return keyCodes !== eventKeyCode;
    }
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function loop(key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) {
        loop(key);
      }
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      process.env.NODE_ENV !== 'production' && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data;
}

/*  */

function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}

/*  */

function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var options = Ctor.options;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    return resolveSlots(children, parent);
  };

  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm = Object.create(parent);
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }
    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    vnode.fnContext = contextVm;
    vnode.fnOptions = options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }

  return vnode;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// Register the component hook to weex native render engine.
// The hook will be triggered by native, not javascript.


// Updates the state of the component to weex native render engine.

/*  */

// https://github.com/Hanks10100/weex-native-directive/tree/master/component

// listening on native callback

/*  */

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var options = {
    _isComponent: true,
    parent: parent,
    _parentVnode: vnode,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options);
}

function mergeHooks(data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1(one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  };
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // warn against non-primitive key
  if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) {
      applyNS(vnode, ns);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {
        applyNS(child, ns, force);
      }
    }
  }
}

/*  */

function initRender(vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (process.env.NODE_ENV !== 'production') {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // if the parent didn't update, the slot nodes will be the ones from
      // last render. They need to be cloned to ensure "freshness" for this render.
      for (var key in vm.$slots) {
        var slot = vm.$slots[key];
        // _rendered is a flag added by renderSlot, but may not be present
        // if the slot is passed from manually written render functions
        if (slot._rendered || slot[0] && slot[0].elm) {
          vm.$slots[key] = cloneVNodes(slot, true /* deep */);
        }
      }
    }

    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };
}

/*  */

var uid$1 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$1++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

function Vue$3(options) {
  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production' && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production' && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache, key, this$1.keys);
    }
  },

  watch: {
    include: function include(val) {
      pruneCache(this, function (name) {
        return matches(val, name);
      });
    },
    exclude: function exclude(val) {
      pruneCache(this, function (name) {
        return !matches(val, name);
      });
    }
  },

  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
      // not included
      include && (!name || !matches(include, name)) ||
      // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || slot && slot[0];
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
});

Vue$3.version = '2.5.13';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function mustUseProp(tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function isXlink(name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function getXlinkProp(name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function isFalsyAttrValue(val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }
  if (isObject(value)) {
    return stringifyObject(value);
  }
  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */
  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }
      res += stringified;
    }
  }
  return res;
}

function stringifyObject(value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }
      res += key;
    }
  }
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function isPreTag(tag) {
  return tag === 'pre';
};

var isReservedTag = function isReservedTag(tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setAttribute(node, key, val) {
  node.setAttribute(key, val);
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove() {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove.listeners = listeners;
    return remove;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (process.env.NODE_ENV !== 'production') {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }
      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setAttribute(vnode.elm, i, '');
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (process.env.NODE_ENV !== 'production') {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return;
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    }
    // assert node match
    if (process.env.NODE_ENV !== 'production') {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false;
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (process.env.NODE_ENV !== 'production') {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);

        // create new node
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function callInsert() {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // #7138: IE10 & 11 fires input event when setting placeholder on
      // <textarea>... block the first input event and remove the blocker
      // immediately.
      /* istanbul ignore if */
      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {
        var blocker = function blocker(e) {
          e.stopImmediatePropagation();
          el.removeEventListener('input', blocker);
        };
        el.addEventListener('input', blocker);
        // $flow-disable-line
        el.__ieph = true; /* IE placeholder patched */
      }
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;break; // "
        case 0x27:
          inSingle = true;break; // '
        case 0x60:
          inTemplateString = true;break; // `
        case 0x28:
          paren++;break; // (
        case 0x29:
          paren--;break; // )
        case 0x5B:
          square++;break; // [
        case 0x5D:
          square--;break; // ]
        case 0x7B:
          curly++;break; // {
        case 0x7D:
          curly--;break; // }
      }
      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0;
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') {
            break;
          }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + "," + args;
  }
}

/*  */

function baseWarn(msg) {
  console.error("[Vue compiler]: " + msg);
}

function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
  el.plain = false;
}

function addAttr(el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
  el.plain = false;
}

// add a raw attr (use this in preTransforms)
function addRawAttr(el, name, value) {
  el.attrsMap[name] = value;
  el.attrsList.push({ name: name, value: value });
}

function addDirective(el, name, rawName, value, arg, modifiers) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
  el.plain = false;
}

function addHandler(el, name, value, modifiers, important, warn) {
  modifiers = modifiers || emptyObject;
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && warn && modifiers.prevent && modifiers.passive) {
    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.');
  }

  // check capture modifier
  if (modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  /* istanbul ignore if */
  if (modifiers.passive) {
    delete modifiers.passive;
    name = '&' + name; // mark the event as passive
  }

  // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.
  if (name === 'click') {
    if (modifiers.right) {
      name = 'contextmenu';
      delete modifiers.right;
    } else if (modifiers.middle) {
      name = 'mouseup';
    }
  }

  var events;
  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = { value: value };
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr(el, name, removeFromMap) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val;
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: "(" + value + ")",
    expression: "\"" + value + "\"",
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode(value, assignment) {
  var res = parseModel(value);
  if (res.key === null) {
    return value + "=" + assignment;
  } else {
    return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;

function parseModel(val) {
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      };
    } else {
      return {
        exp: val,
        key: null
      };
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }
    if (chr === 0x5B) {
      inBracket++;
    }
    if (chr === 0x5D) {
      inBracket--;
    }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break;
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (process.env.NODE_ENV !== 'production') {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (process.env.NODE_ENV !== 'production') {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
  }

  // ensure runtime directive metadata
  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + value + "=$$a.concat([$$v]))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type;

  // warn if v-bind:value conflicts with v-model
  if (process.env.NODE_ENV !== 'production') {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    if (value$1) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally');
    }
  }

  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler(handler, event, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler() {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
}

function add$1(event, handler, once$$1, capture, passive) {
  handler = withMacroTask(handler);
  if (once$$1) {
    handler = createOnceHandler(handler, event, capture);
  }
  target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}
  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.lazy) {
      // inputs with lazy should only be updated when not in focus
      return false;
    }
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function setProp(el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition(def) {
  if (!def) {
    return;
  }
  /* istanbul ignore else */
  if ((typeof def === 'undefined' ? 'undefined' : _typeof(def)) === 'object') {
    var res = {};
    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }
    extend(res, def);
    return res;
  } else if (typeof def === 'string') {
    return autoCssTransition(def);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function end() {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function onEnd(e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return;
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) {
      return c.tag || isAsyncPlaceholder(c);
    });
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&
    // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }
        var delayedLeave;
        var performLeave = function performLeave() {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (process.env.NODE_ENV !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
Vue$3.nextTick(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
    }
  }
  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
  }
}, 0);

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return;
  }
  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;
  while (match = tagRE.exec(text)) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    rawTokens.push({ '@binding': exp });
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }
  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  };
}

/*  */

function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if (process.env.NODE_ENV !== 'production' && staticClass) {
    var res = parseText(staticClass, options.delimiters);
    if (res) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData(el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }
  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }
  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      var res = parseText(staticStyle, options.delimiters);
      if (res) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1(el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }
  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

/*  */

var decoder;

var he = {
  decode: function decode(html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent;
  }
};

/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i;
var comment = /^<!--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd));
            }
            advance(commentEnd + 3);
            continue;
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(lastTag, html)) {
            advance(1);
          }
          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) {
            break;
          }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return '';
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
      }
      break;
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') {
          delete args[3];
        }
        if (args[4] === '') {
          delete args[4];
        }
        if (args[5] === '') {
          delete args[5];
        }
      }
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) {
      start = index;
    }
    if (end == null) {
      end = index;
    }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(he.decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;

function createASTElement(tag, attrs, parent) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    parent: parent,
    children: []
  };
}

/**
 * Convert HTML string to AST.
 */
function parse(template, options) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function closeElement(element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
    // apply post-transforms
    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    start: function start(tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
        // element-scope stuff
        processElement(element, options);
      }

      function checkRootConstraints(el) {
        if (process.env.NODE_ENV !== 'production') {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (process.env.NODE_ENV !== 'production') {
          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) {
          // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },

    end: function end() {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      closeElement(element);
    },

    chars: function chars(text) {
      if (!currentParent) {
        if (process.env.NODE_ENV !== 'production') {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.');
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.");
          }
        }
        return;
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }
      var children = currentParent.children;
      text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
      // only preserve whitespace if its not right after a starting tag
      : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var res;
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    },
    comment: function comment(text) {
      currentParent.children.push({
        type: 3,
        text: text,
        isComment: true
      });
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement(element, options) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = !element.key && !element.attrsList.length;

  processRef(element);
  processSlot(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;
  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var res = parseFor(exp);
    if (res) {
      extend(el, res);
    } else if (process.env.NODE_ENV !== 'production') {
      warn$2("Invalid v-for expression: " + exp);
    }
  }
}

function parseFor(exp) {
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) {
    return;
  }
  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);
  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '');
    res.iterator1 = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }
  return res;
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (process.env.NODE_ENV !== 'production') {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
  }
}

function findPrevElement(children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
      }
      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if (process.env.NODE_ENV !== 'production' && el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
    }
  } else {
    var slotScope;
    if (el.tag === 'template') {
      slotScope = getAndRemoveAttr(el, 'scope');
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && slotScope) {
        warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", true);
      }
      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
    } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && el.attrsMap['v-for']) {
        warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", true);
      }
      el.slotScope = slotScope;
    }
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      // preserve slot as an attribute for native shadow DOM compat
      // only for non-scoped slots.
      if (el.tag !== 'template' && !el.slotScope) {
        addAttr(el, 'slot', slotTarget);
      }
    }
  }
}

function processComponent(el) {
  var binding;
  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            addHandler(el, "update:" + camelize(name), genAssignmentCode(value, "$event"));
          }
        }
        if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers, false, warn$2);
      } else {
        // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if (process.env.NODE_ENV !== 'production' && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (process.env.NODE_ENV !== 'production') {
        var res = parseText(value, delimiters);
        if (res) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
        }
      }
      addAttr(el, name, JSON.stringify(value));
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true');
      }
    }
  }
}

function checkInFor(el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }
    parent = parent.parent;
  }
  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map;
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug(attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
    }
    _el = _el.parent;
  }
}

/*  */

/**
 * Expand input[v-model] with dyanmic type bindings into v-if-else chains
 * Turn this:
 *   <input v-model="data[type]" :type="type">
 * into this:
 *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
 *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
 *   <input v-else :type="type" v-model="data[type]">
 */

function preTransformNode(el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (map['v-model'] && (map['v-bind:type'] || map[':type'])) {
      var typeBinding = getBindingAttr(el, 'type');
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0;
    }
  }
}

function cloneASTElement(el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent);
}

var model$2 = {
  preTransformNode: preTransformNode
};

var modules$1 = [klass$1, style$1, model$2];

/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")");
  }
}

/*  */

function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")");
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize(root, options) {
  if (!root) {
    return;
  }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }
  if (node.type === 3) {
    // text
    return true;
  }
  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false;
    }
    if (node.for) {
      return true;
    }
  }
  return false;
}

/*  */

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function genGuard(condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, isNative, warn) {
  var res = isNative ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    res += "\"" + name + "\":" + genHandler(name, events[name]) + ",";
  }
  return res.slice(0, -1) + '}';
}

function genHandler(name, handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(name, handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value;
    }
    /* istanbul ignore if */
    return "function($event){" + handler.value + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = handler.modifiers;
        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
          return !modifiers[keyModifier];
        }).map(function (keyModifier) {
          return "$event." + keyModifier + "Key";
        }).join('||'));
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
    /* istanbul ignore if */
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }
  var code = keyCodes[key];
  return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(code) + "," + "$event.key)";
}

/*  */

function on(el, dir) {
  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) {
    return "_g(" + code + "," + dir.value + ")";
  };
}

/*  */

function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */

var CodegenState = function CodegenState(options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) {
    return !isReservedTag(el.tag);
  };
  this.onceId = 0;
  this.staticRenderFns = [];
};

function generate(ast, options) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data = el.plain ? undefined : genData$2(el, state);

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code;
  }
}

// hoist static sub-trees out
function genStatic(el, state) {
  el.staticProcessed = true;
  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
}

// v-once
function genOnce(el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }
      parent = parent.parent;
    }
    if (!key) {
      process.env.NODE_ENV !== 'production' && state.warn("v-once can only be used inside v-for that is keyed. ");
      return genElement(el, state);
    }
    return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
  } else {
    return genStatic(el, state);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return "" + genTernaryExp(condition.block);
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (process.env.NODE_ENV !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
}

function genData$2(el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) {
    data += dirs + ',';
  }

  // key
  if (el.key) {
    data += "key:" + el.key + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + genProps(el.attrs) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + genProps(el.props) + "},";
  }
  // event handlers
  if (el.events) {
    data += genHandlers(el.events, false, state.warn) + ",";
  }
  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true, state.warn) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + el.slotTarget + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += genScopedSlots(el.scopedSlots, state) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;
  if (!dirs) {
    return;
  }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];
  if (process.env.NODE_ENV !== 'production' && (el.children.length !== 1 || ast.type !== 1)) {
    state.warn('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(slots, state) {
  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(key, slots[key], state);
  }).join(',') + "])";
}

function genScopedSlot(key, el, state) {
  if (el.for && !el.forProcessed) {
    return genForScopedSlot(key, el, state);
  }
  var fn = "function(" + String(el.slotScope) + "){" + "return " + (el.tag === 'template' ? el.if ? el.if + "?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}";
  return "{key:" + key + ",fn:" + fn + "}";
}

function genForScopedSlot(key, el, state) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genScopedSlot(key, el, state) + '})';
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      return (altGenElement || genElement)(el$1, state);
    }
    var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return "[" + children.map(function (c) {
      return gen(c, state);
    }).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType(children, maybeComponent) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue;
    }
    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }
    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }
  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  }if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genComment(comment) {
  return "_e(" + JSON.stringify(comment.text) + ")";
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs && "{" + el.attrs.map(function (a) {
    return camelize(a.name) + ":" + a.value;
  }).join(',') + "}";
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')';
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    /* istanbul ignore if */
    {
      res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
    }
  }
  return res.slice(0, -1);
}

// #3895, #4268
function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors(ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors;
}

function checkNode(node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", errors);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", errors);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent(exp, text, errors) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);
  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
  }
  checkExpression(exp, text, errors);
}

function checkFor(node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier(ident, type, text, errors) {
  if (typeof ident === 'string') {
    try {
      new Function("var " + ident + "=_");
    } catch (e) {
      errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
    }
  }
}

function checkExpression(exp, text, errors) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim());
    } else {
      errors.push("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n");
    }
  }
}

/*  */

function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop;
  }
}

function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);

  return function compileToFunctions(template, options, vm) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    }

    // check cache
    var key = options.delimiters ? String(options.delimiters) + template : template;
    if (cache[key]) {
      return cache[key];
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (process.env.NODE_ENV !== 'production') {
      if (compiled.errors && compiled.errors.length) {
        warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
          return "- " + e;
        }).join('\n') + '\n', vm);
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) {
          return tip(msg, vm);
        });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;

          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }

    return cache[key] = res;
  };
}

/*  */

function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];
      finalOptions.warn = function (msg, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        // merge custom modules
        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      var compiled = baseCompile(template, finalOptions);
      if (process.env.NODE_ENV !== 'production') {
        errors.push.apply(errors, detectErrors(compiled.ast));
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile(template, options) {
  var ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    optimize(ast, options);
  }
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

// check whether current browser encodes a char inside attribute values
var div;
function getShouldDecode(href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0;
}

// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});

var mount = Vue$3.prototype.$mount;
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end');
        measure("vue " + this._name + " compile", 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating);
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue$3.compile = compileToFunctions;

exports.default = Vue$3;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js"), __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),

/***/ "./src/app.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_app_vue__ = __webpack_require__("./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/app.vue");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_app_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_app_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_app_vue__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_app_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ef48958_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_app_vue__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-5ef48958\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/app.vue");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__node_modules_vue_loader_lib_runtime_component_normalizer__ = __webpack_require__("./node_modules/vue-loader/lib/runtime/component-normalizer.js");
var disposed = false
function injectStyle (context) {
  if (disposed) return
  __webpack_require__("./node_modules/vue-style-loader/index.js!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-5ef48958\",\"scoped\":false,\"sourceMap\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/app.vue")
}
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null

var Component = Object(__WEBPACK_IMPORTED_MODULE_2__node_modules_vue_loader_lib_runtime_component_normalizer__["a" /* default */])(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_app_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ef48958_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_app_vue__["a" /* render */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_5ef48958_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_app_vue__["b" /* staticRenderFns */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/app.vue"

/* hot reload */
if (true) {(function () {
  var hotAPI = __webpack_require__("./node_modules/vue-hot-reload-api/dist/index.js")
  hotAPI.install(__webpack_require__("./node_modules/vue/dist/vue.esm.js"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5ef48958", Component.options)
  } else {
    hotAPI.reload("data-v-5ef48958", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),

/***/ "./src/main.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _vue = __webpack_require__("./node_modules/vue/dist/vue.esm.js");

var _vue2 = _interopRequireDefault(_vue);

var _vueRouter = __webpack_require__("./node_modules/vue-router/dist/vue-router.esm.js");

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _routes = __webpack_require__("./src/routes.js");

var _routes2 = _interopRequireDefault(_routes);

var _app = __webpack_require__("./src/app.vue");

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vueRouter2.default);

var RouterConfig = {
    routes: _routes2.default
};
var router = new _vueRouter2.default(RouterConfig);

new _vue2.default({
    el: '#root',
    router: router,
    render: function render(h) {
        return h(_app2.default);
    }
});

/***/ }),

/***/ "./src/routes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _vue = __webpack_require__("./node_modules/vue/dist/vue.esm.js");

var _vue2 = _interopRequireDefault(_vue);

var _vueRouter = __webpack_require__("./node_modules/vue-router/dist/vue-router.esm.js");

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _routes = __webpack_require__("./src/routes.js");

var _routes2 = _interopRequireDefault(_routes);

var _app = __webpack_require__("./src/app.vue");

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vueRouter2.default);

var RouterConfig = {
    routes: _routes2.default
};
var router = new _vueRouter2.default(RouterConfig);

new _vue2.default({
    el: '#root',
    router: router,
    render: function render(h) {
        return h(_app2.default);
    }
});

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNTIxN2E1YTEwM2NkNjliMzBkYTkiLCJ3ZWJwYWNrOi8vL3NyYy9hcHAudnVlIiwid2VicGFjazovLy8uL3NyYy9hcHAudnVlPzEyYWMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzIiwid2VicGFjazovLy8uL3NyYy9hcHAudnVlPzI5YmMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwLnZ1ZT9kZDU4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9hcHAudnVlIiwid2VicGFjazovLy8uL3NyYy9tYWluLmpzIiwid2VicGFjazovLy8uL3NyYy9yb3V0ZXMuanMiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwibGVuZ3RoIiwiaWQiLCJwdXNoIiwiY3NzTWFwcGluZyIsImJ0b2EiLCJzb3VyY2VNYXBwaW5nIiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZXMiLCJzb3VyY2UiLCJzb3VyY2VSb290IiwiY29uY2F0Iiwic291cmNlTWFwIiwiYmFzZTY0IiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIiwic3RyaW5naWZ5IiwiZGF0YSIsInByb2Nlc3MiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwiZ2xvYmFsIiwidW5kZWZpbmVkIiwic2V0SW1tZWRpYXRlIiwibmV4dEhhbmRsZSIsInRhc2tzQnlIYW5kbGUiLCJjdXJyZW50bHlSdW5uaW5nQVRhc2siLCJkb2MiLCJkb2N1bWVudCIsInJlZ2lzdGVySW1tZWRpYXRlIiwiY2FsbGJhY2siLCJGdW5jdGlvbiIsInRhc2siLCJjbGVhckltbWVkaWF0ZSIsImhhbmRsZSIsInJ1bklmUHJlc2VudCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4IiwiTWF0aCIsInJhbmRvbSIsIm9uR2xvYmFsTWVzc2FnZSIsImV2ZW50IiwiaW5kZXhPZiIsInNsaWNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwic2VsZiIsIlRpbWVvdXQiLCJ3aW5kb3ciLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJjbG9zZSIsImNsZWFyRm4iLCJfaWQiLCJfY2xlYXJGbiIsInVucmVmIiwicmVmIiwiZW5yb2xsIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwiYWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsInJlcXVpcmUiLCJWdWUiLCJfX1ZVRV9IT1RfTUFQX18iLCJjcmVhdGUiLCJpbnN0YWxsZWQiLCJpc0Jyb3dzZXJpZnkiLCJpbml0SG9va05hbWUiLCJpbnN0YWxsIiwidnVlIiwiYnJvd3NlcmlmeSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0Iiwic3BsaXQiLCJOdW1iZXIiLCJjb25maWciLCJfbGlmZWN5Y2xlSG9va3MiLCJjb21wYXRpYmxlIiwiY29uc29sZSIsIndhcm4iLCJjcmVhdGVSZWNvcmQiLCJvcHRpb25zIiwiQ3RvciIsIm1ha2VPcHRpb25zSG90IiwiaW5zdGFuY2VzIiwiaXNSZWNvcmRlZCIsImZ1bmN0aW9uYWwiLCJyZW5kZXIiLCJoIiwiY3R4IiwicGFyZW50IiwiaW5qZWN0SG9vayIsInJlY29yZCIsImNvbnN0cnVjdG9yIiwic3BsaWNlIiwiaG9vayIsImV4aXN0aW5nIiwiaXNBcnJheSIsInRyeVdyYXAiLCJmbiIsImFyZyIsImVycm9yIiwidXBkYXRlT3B0aW9ucyIsIm9sZE9wdGlvbnMiLCJuZXdPcHRpb25zIiwia2V5Iiwia2V5JDEiLCJyZXJlbmRlciIsImZvckVhY2giLCJpbnN0YW5jZSIsIiRmb3JjZVVwZGF0ZSIsInN0YXRpY1JlbmRlckZucyIsIiRvcHRpb25zIiwiX3N0YXRpY1RyZWVzIiwiY2FjaGVkIiwia2V5cyIsImluamVjdFN0eWxlcyIsIl9pbmplY3RTdHlsZXMiLCJfQ3RvciIsInJlbG9hZCIsImV4dGVuZE9wdGlvbnMiLCJuZXdDdG9yIiwic3VwZXIiLCJleHRlbmQiLCJjaWQiLCJyZWxlYXNlIiwiJHZub2RlIiwiY29udGV4dCIsImFzc2VydCIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJOT0RFX0VOViIsImlzRXJyb3IiLCJlcnIiLCJWaWV3IiwicHJvcHMiLCJ0eXBlIiwiU3RyaW5nIiwiXyIsImNoaWxkcmVuIiwicm91dGVyVmlldyIsIiRjcmVhdGVFbGVtZW50Iiwicm91dGUiLCIkcm91dGUiLCJjYWNoZSIsIl9yb3V0ZXJWaWV3Q2FjaGUiLCJkZXB0aCIsImluYWN0aXZlIiwiX3JvdXRlclJvb3QiLCJfaW5hY3RpdmUiLCIkcGFyZW50Iiwicm91dGVyVmlld0RlcHRoIiwibWF0Y2hlZCIsImNvbXBvbmVudCIsImNvbXBvbmVudHMiLCJyZWdpc3RlclJvdXRlSW5zdGFuY2UiLCJ2bSIsInZhbCIsImN1cnJlbnQiLCJwcmVwYXRjaCIsInZub2RlIiwiY29tcG9uZW50SW5zdGFuY2UiLCJwcm9wc1RvUGFzcyIsInJlc29sdmVQcm9wcyIsImF0dHJzIiwicGFyYW1zIiwicGF0aCIsInRvIiwiZnJvbSIsImVuY29kZVJlc2VydmVSRSIsImVuY29kZVJlc2VydmVSZXBsYWNlciIsImMiLCJjaGFyQ29kZUF0IiwiY29tbWFSRSIsImVuY29kZSIsInN0ciIsInJlcGxhY2UiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJyZXNvbHZlUXVlcnkiLCJxdWVyeSIsImV4dHJhUXVlcnkiLCJfcGFyc2VRdWVyeSIsInBhcnNlIiwicGFyc2VRdWVyeSIsInBhcnNlZFF1ZXJ5IiwicmVzIiwidHJpbSIsInBhcmFtIiwicGFydHMiLCJzaGlmdCIsInN0cmluZ2lmeVF1ZXJ5Iiwib2JqIiwicmVzdWx0IiwidmFsMiIsImZpbHRlciIsIngiLCJ0cmFpbGluZ1NsYXNoUkUiLCJjcmVhdGVSb3V0ZSIsImxvY2F0aW9uIiwicmVkaXJlY3RlZEZyb20iLCJyb3V0ZXIiLCJzdHJpbmdpZnlRdWVyeSQkMSIsImNsb25lIiwibWV0YSIsImhhc2giLCJmdWxsUGF0aCIsImdldEZ1bGxQYXRoIiwiZm9ybWF0TWF0Y2giLCJmcmVlemUiLCJ2YWx1ZSIsIlNUQVJUIiwidW5zaGlmdCIsIl9zdHJpbmdpZnlRdWVyeSIsImlzU2FtZVJvdXRlIiwiYSIsImIiLCJpc09iamVjdEVxdWFsIiwiYUtleXMiLCJiS2V5cyIsImV2ZXJ5IiwiYVZhbCIsImJWYWwiLCJpc0luY2x1ZGVkUm91dGUiLCJ0YXJnZXQiLCJxdWVyeUluY2x1ZGVzIiwidG9UeXBlcyIsImV2ZW50VHlwZXMiLCJMaW5rIiwicmVxdWlyZWQiLCJ0YWciLCJleGFjdCIsIkJvb2xlYW4iLCJhcHBlbmQiLCJhY3RpdmVDbGFzcyIsImV4YWN0QWN0aXZlQ2xhc3MiLCJ0aGlzJDEiLCIkcm91dGVyIiwicmVzb2x2ZSIsImhyZWYiLCJjbGFzc2VzIiwiZ2xvYmFsQWN0aXZlQ2xhc3MiLCJsaW5rQWN0aXZlQ2xhc3MiLCJnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzIiwibGlua0V4YWN0QWN0aXZlQ2xhc3MiLCJhY3RpdmVDbGFzc0ZhbGxiYWNrIiwiZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrIiwiY29tcGFyZVRhcmdldCIsImhhbmRsZXIiLCJndWFyZEV2ZW50IiwiY2xpY2siLCJjbGFzcyIsImZpbmRBbmNob3IiLCIkc2xvdHMiLCJpc1N0YXRpYyIsIl9WdWUiLCJ1dGlsIiwiYURhdGEiLCJhQXR0cnMiLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiZGVmYXVsdFByZXZlbnRlZCIsImJ1dHRvbiIsImN1cnJlbnRUYXJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJ0ZXN0IiwicHJldmVudERlZmF1bHQiLCJjaGlsZCIsImlzRGVmIiwidiIsInJlZ2lzdGVySW5zdGFuY2UiLCJjYWxsVmFsIiwiX3BhcmVudFZub2RlIiwibWl4aW4iLCJiZWZvcmVDcmVhdGUiLCJfcm91dGVyIiwiaW5pdCIsImRlZmluZVJlYWN0aXZlIiwiaGlzdG9yeSIsImRlc3Ryb3llZCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiX3JvdXRlIiwic3RyYXRzIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwiYmVmb3JlUm91dGVFbnRlciIsImJlZm9yZVJvdXRlTGVhdmUiLCJiZWZvcmVSb3V0ZVVwZGF0ZSIsImNyZWF0ZWQiLCJpbkJyb3dzZXIiLCJyZXNvbHZlUGF0aCIsInJlbGF0aXZlIiwiYmFzZSIsImZpcnN0Q2hhciIsImNoYXJBdCIsInN0YWNrIiwicG9wIiwic2VnbWVudHMiLCJzZWdtZW50IiwicGFyc2VQYXRoIiwiaGFzaEluZGV4IiwicXVlcnlJbmRleCIsImNsZWFuUGF0aCIsImlzYXJyYXkiLCJhcnIiLCJwYXRoVG9SZWdleHBfMSIsInBhdGhUb1JlZ2V4cCIsInBhcnNlXzEiLCJjb21waWxlXzEiLCJjb21waWxlIiwidG9rZW5zVG9GdW5jdGlvbl8xIiwidG9rZW5zVG9GdW5jdGlvbiIsInRva2Vuc1RvUmVnRXhwXzEiLCJ0b2tlbnNUb1JlZ0V4cCIsIlBBVEhfUkVHRVhQIiwiUmVnRXhwIiwidG9rZW5zIiwiaW5kZXgiLCJkZWZhdWx0RGVsaW1pdGVyIiwiZGVsaW1pdGVyIiwiZXhlYyIsIm0iLCJlc2NhcGVkIiwib2Zmc2V0IiwibmV4dCIsInByZWZpeCIsImNhcHR1cmUiLCJncm91cCIsIm1vZGlmaWVyIiwiYXN0ZXJpc2siLCJwYXJ0aWFsIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJwYXR0ZXJuIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJzdWJzdHIiLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJ0b1VwcGVyQ2FzZSIsImVuY29kZUFzdGVyaXNrIiwibWF0Y2hlcyIsIm9wdHMiLCJwcmV0dHkiLCJ0b2tlbiIsIlR5cGVFcnJvciIsImoiLCJhdHRhY2hLZXlzIiwicmUiLCJmbGFncyIsInNlbnNpdGl2ZSIsInJlZ2V4cFRvUmVnZXhwIiwiZ3JvdXBzIiwibWF0Y2giLCJhcnJheVRvUmVnZXhwIiwicmVnZXhwIiwic3RyaW5nVG9SZWdleHAiLCJzdHJpY3QiLCJlbmQiLCJlbmRzV2l0aERlbGltaXRlciIsInJlZ2V4cENvbXBpbGVDYWNoZSIsImZpbGxQYXJhbXMiLCJyb3V0ZU1zZyIsImZpbGxlciIsImNyZWF0ZVJvdXRlTWFwIiwicm91dGVzIiwib2xkUGF0aExpc3QiLCJvbGRQYXRoTWFwIiwib2xkTmFtZU1hcCIsInBhdGhMaXN0IiwicGF0aE1hcCIsIm5hbWVNYXAiLCJhZGRSb3V0ZVJlY29yZCIsImwiLCJtYXRjaEFzIiwicGF0aFRvUmVnZXhwT3B0aW9ucyIsIm5vcm1hbGl6ZWRQYXRoIiwibm9ybWFsaXplUGF0aCIsImNhc2VTZW5zaXRpdmUiLCJyZWdleCIsImNvbXBpbGVSb3V0ZVJlZ2V4IiwicmVkaXJlY3QiLCJiZWZvcmVFbnRlciIsInNvbWUiLCJjaGlsZE1hdGNoQXMiLCJhbGlhcyIsImFsaWFzZXMiLCJhbGlhc1JvdXRlIiwibm9ybWFsaXplTG9jYXRpb24iLCJyYXciLCJfbm9ybWFsaXplZCIsImFzc2lnbiIsInJhd1BhdGgiLCJwYXJzZWRQYXRoIiwiYmFzZVBhdGgiLCJjcmVhdGVNYXRjaGVyIiwiYWRkUm91dGVzIiwiY3VycmVudFJvdXRlIiwiX2NyZWF0ZVJvdXRlIiwicGFyYW1OYW1lcyIsInJlY29yZCQxIiwibWF0Y2hSb3V0ZSIsIm9yaWdpbmFsUmVkaXJlY3QiLCJoYXNPd25Qcm9wZXJ0eSIsInRhcmdldFJlY29yZCIsInJlc29sdmVSZWNvcmRQYXRoIiwicmVzb2x2ZWRQYXRoIiwiYWxpYXNlZFBhdGgiLCJhbGlhc2VkTWF0Y2giLCJhbGlhc2VkUmVjb3JkIiwicG9zaXRpb25TdG9yZSIsInNldHVwU2Nyb2xsIiwicmVwbGFjZVN0YXRlIiwiZ2V0U3RhdGVLZXkiLCJzYXZlU2Nyb2xsUG9zaXRpb24iLCJzdGF0ZSIsInNldFN0YXRlS2V5IiwiaGFuZGxlU2Nyb2xsIiwiaXNQb3AiLCJhcHAiLCJiZWhhdmlvciIsInNjcm9sbEJlaGF2aW9yIiwiJG5leHRUaWNrIiwicG9zaXRpb24iLCJnZXRTY3JvbGxQb3NpdGlvbiIsInNob3VsZFNjcm9sbCIsInRoZW4iLCJzY3JvbGxUb1Bvc2l0aW9uIiwiY2F0Y2giLCJwYWdlWE9mZnNldCIsInkiLCJwYWdlWU9mZnNldCIsImdldEVsZW1lbnRQb3NpdGlvbiIsImVsIiwiZG9jRWwiLCJkb2NSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZWxSZWN0IiwibGVmdCIsInRvcCIsImlzVmFsaWRQb3NpdGlvbiIsImlzTnVtYmVyIiwibm9ybWFsaXplUG9zaXRpb24iLCJub3JtYWxpemVPZmZzZXQiLCJpc09iamVjdCIsInNlbGVjdG9yIiwicXVlcnlTZWxlY3RvciIsInNjcm9sbFRvIiwic3VwcG9ydHNQdXNoU3RhdGUiLCJ1YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIlRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIkRhdGUiLCJfa2V5IiwiZ2VuS2V5IiwidG9GaXhlZCIsInB1c2hTdGF0ZSIsInVybCIsInJ1blF1ZXVlIiwiY2IiLCJzdGVwIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50cyIsImhhc0FzeW5jIiwicGVuZGluZyIsImZsYXRNYXBDb21wb25lbnRzIiwiZGVmIiwicmVzb2x2ZWREZWYiLCJpc0VTTW9kdWxlIiwicmVzb2x2ZWQiLCJyZWplY3QiLCJyZWFzb24iLCJtc2ciLCJjb21wIiwiZmxhdHRlbiIsImhhc1N5bWJvbCIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiY2FsbGVkIiwiSGlzdG9yeSIsIm5vcm1hbGl6ZUJhc2UiLCJyZWFkeSIsInJlYWR5Q2JzIiwicmVhZHlFcnJvckNicyIsImVycm9yQ2JzIiwibGlzdGVuIiwib25SZWFkeSIsImVycm9yQ2IiLCJvbkVycm9yIiwidHJhbnNpdGlvblRvIiwib25Db21wbGV0ZSIsIm9uQWJvcnQiLCJjb25maXJtVHJhbnNpdGlvbiIsInVwZGF0ZVJvdXRlIiwiZW5zdXJlVVJMIiwiYWJvcnQiLCJyZXNvbHZlUXVldWUiLCJ1cGRhdGVkIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJleHRyYWN0TGVhdmVHdWFyZHMiLCJiZWZvcmVIb29rcyIsImV4dHJhY3RVcGRhdGVIb29rcyIsIml0ZXJhdG9yIiwicG9zdEVudGVyQ2JzIiwiaXNWYWxpZCIsImVudGVyR3VhcmRzIiwiZXh0cmFjdEVudGVyR3VhcmRzIiwicmVzb2x2ZUhvb2tzIiwicHJldiIsImFmdGVySG9va3MiLCJiYXNlRWwiLCJtYXgiLCJleHRyYWN0R3VhcmRzIiwicmVjb3JkcyIsImJpbmQiLCJyZXZlcnNlIiwiZ3VhcmRzIiwiZ3VhcmQiLCJleHRyYWN0R3VhcmQiLCJiaW5kR3VhcmQiLCJib3VuZFJvdXRlR3VhcmQiLCJjYnMiLCJiaW5kRW50ZXJHdWFyZCIsInJvdXRlRW50ZXJHdWFyZCIsInBvbGwiLCJIVE1MNUhpc3RvcnkiLCJIaXN0b3J5JCQxIiwiZXhwZWN0U2Nyb2xsIiwiaW5pdExvY2F0aW9uIiwiZ2V0TG9jYXRpb24iLCJfX3Byb3RvX18iLCJnbyIsIm4iLCJmcm9tUm91dGUiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJwYXRobmFtZSIsInNlYXJjaCIsIkhhc2hIaXN0b3J5IiwiZmFsbGJhY2siLCJjaGVja0ZhbGxiYWNrIiwiZW5zdXJlU2xhc2giLCJzZXR1cExpc3RlbmVycyIsInN1cHBvcnRzU2Nyb2xsIiwiZ2V0SGFzaCIsInJlcGxhY2VIYXNoIiwicHVzaEhhc2giLCJnZXRVcmwiLCJBYnN0cmFjdEhpc3RvcnkiLCJ0YXJnZXRJbmRleCIsIlZ1ZVJvdXRlciIsImFwcHMiLCJtYXRjaGVyIiwibW9kZSIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNvbmZpZ3VyYWJsZSIsInNldHVwSGFzaExpc3RlbmVyIiwiYmVmb3JlRWFjaCIsInJlZ2lzdGVySG9vayIsImJlZm9yZVJlc29sdmUiLCJhZnRlckVhY2giLCJiYWNrIiwiZm9yd2FyZCIsImdldE1hdGNoZWRDb21wb25lbnRzIiwiY3JlYXRlSHJlZiIsIm5vcm1hbGl6ZWRUbyIsImRlZmluZVByb3BlcnRpZXMiLCJ1c2UiLCJsaXN0VG9TdHlsZXMiLCJwYXJlbnRJZCIsInN0eWxlcyIsIm5ld1N0eWxlcyIsImNzcyIsIm1lZGlhIiwicGFydCIsImVtcHR5T2JqZWN0IiwiaXNVbmRlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsIl90b1N0cmluZyIsInRvUmF3VHlwZSIsImlzUGxhaW5PYmplY3QiLCJpc1JlZ0V4cCIsImlzVmFsaWRBcnJheUluZGV4IiwicGFyc2VGbG9hdCIsImZsb29yIiwiaXNGaW5pdGUiLCJ0b051bWJlciIsImlzTmFOIiwibWFrZU1hcCIsImV4cGVjdHNMb3dlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsImlzQnVpbHRJblRhZyIsImlzUmVzZXJ2ZWRBdHRyaWJ1dGUiLCJyZW1vdmUiLCJoYXNPd24iLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsImNhcGl0YWxpemUiLCJoeXBoZW5hdGVSRSIsImh5cGhlbmF0ZSIsImJvdW5kRm4iLCJfbGVuZ3RoIiwidG9BcnJheSIsInN0YXJ0IiwicmV0IiwiX2Zyb20iLCJ0b09iamVjdCIsIm5vIiwiaWRlbnRpdHkiLCJnZW5TdGF0aWNLZXlzIiwicmVkdWNlIiwic3RhdGljS2V5cyIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJpc0FycmF5QSIsImlzQXJyYXlCIiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIlNTUl9BVFRSIiwiQVNTRVRfVFlQRVMiLCJMSUZFQ1lDTEVfSE9PS1MiLCJzaWxlbnQiLCJwcm9kdWN0aW9uVGlwIiwiZGV2dG9vbHMiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJpc1Jlc2VydmVkIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiYmFpbFJFIiwiaGFzUHJvdG8iLCJpbldlZXgiLCJXWEVudmlyb25tZW50IiwicGxhdGZvcm0iLCJ3ZWV4UGxhdGZvcm0iLCJVQSIsImlzSUUiLCJpc0lFOSIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNDaHJvbWUiLCJuYXRpdmVXYXRjaCIsIndhdGNoIiwic3VwcG9ydHNQYXNzaXZlIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiUmVmbGVjdCIsIm93bktleXMiLCJfU2V0IiwiU2V0Iiwic2V0IiwiaGFzIiwiYWRkIiwiY2xlYXIiLCJ0aXAiLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJ0cmFjZSIsImluY2x1ZGVGaWxlIiwiJHJvb3QiLCJfaXNWdWUiLCJfY29tcG9uZW50VGFnIiwiZmlsZSIsIl9fZmlsZSIsInRyZWUiLCJjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UiLCJsYXN0IiwidWlkIiwiRGVwIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsImFkZERlcCIsIm5vdGlmeSIsInVwZGF0ZSIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsIl90YXJnZXQiLCJwb3BUYXJnZXQiLCJWTm9kZSIsInRleHQiLCJlbG0iLCJjb21wb25lbnRPcHRpb25zIiwiYXN5bmNGYWN0b3J5IiwibnMiLCJmbkNvbnRleHQiLCJmbk9wdGlvbnMiLCJmblNjb3BlSWQiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsImFzeW5jTWV0YSIsImlzQXN5bmNQbGFjZWhvbGRlciIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsImRlZXAiLCJjbG9uZWQiLCJjbG9uZVZOb2RlcyIsInZub2RlcyIsImFycmF5UHJvdG8iLCJhcnJheU1ldGhvZHMiLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm9ic2VydmVyU3RhdGUiLCJzaG91bGRDb252ZXJ0IiwiT2JzZXJ2ZXIiLCJ2bUNvdW50IiwiYXVnbWVudCIsInByb3RvQXVnbWVudCIsImNvcHlBdWdtZW50Iiwid2FsayIsIml0ZW1zIiwib2JzZXJ2ZSIsInNyYyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJzaGFsbG93IiwicHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJjaGlsZE9iIiwicmVhY3RpdmVHZXR0ZXIiLCJkZXBlbmRBcnJheSIsInJlYWN0aXZlU2V0dGVyIiwibmV3VmFsIiwiZGVsIiwicHJvcHNEYXRhIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsIm1lcmdlQXNzZXRzIiwiYXNzZXJ0T2JqZWN0VHlwZSIsIm1ldGhvZHMiLCJpbmplY3QiLCJjb21wdXRlZCIsInByb3ZpZGUiLCJjaGVja0NvbXBvbmVudHMiLCJ2YWxpZGF0ZUNvbXBvbmVudE5hbWUiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZUluamVjdCIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwiZGlycyIsImRpcmVjdGl2ZXMiLCJtZXJnZU9wdGlvbnMiLCJleHRlbmRzRnJvbSIsImV4dGVuZHMiLCJtaXhpbnMiLCJtZXJnZUZpZWxkIiwic3RyYXQiLCJyZXNvbHZlQXNzZXQiLCJ3YXJuTWlzc2luZyIsImFzc2V0cyIsImNhbWVsaXplZElkIiwiUGFzY2FsQ2FzZUlkIiwidmFsaWRhdGVQcm9wIiwicHJvcE9wdGlvbnMiLCJwcm9wIiwiYWJzZW50IiwiaXNUeXBlIiwiZ2V0UHJvcERlZmF1bHRWYWx1ZSIsInByZXZTaG91bGRDb252ZXJ0IiwiYXNzZXJ0UHJvcCIsIl9wcm9wcyIsImdldFR5cGUiLCJ2YWxpZCIsImV4cGVjdGVkVHlwZXMiLCJhc3NlcnRlZFR5cGUiLCJhc3NlcnRUeXBlIiwiZXhwZWN0ZWRUeXBlIiwidmFsaWRhdG9yIiwic2ltcGxlQ2hlY2tSRSIsInQiLCJoYW5kbGVFcnJvciIsImluZm8iLCJjdXIiLCJob29rcyIsImVycm9yQ2FwdHVyZWQiLCJnbG9iYWxIYW5kbGVFcnJvciIsImxvZ0Vycm9yIiwiY2FsbGJhY2tzIiwiZmx1c2hDYWxsYmFja3MiLCJjb3BpZXMiLCJtaWNyb1RpbWVyRnVuYyIsIm1hY3JvVGltZXJGdW5jIiwidXNlTWFjcm9UYXNrIiwicG9ydCIsIlByb21pc2UiLCJwIiwid2l0aE1hY3JvVGFzayIsIl93aXRoVGFzayIsIl9yZXNvbHZlIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJzZWVuIiwiaXNBIiwiaXNGcm96ZW4iLCJkZXBJZCIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwiYXJndW1lbnRzJDEiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbGRPbiIsInJlbW92ZSQkMSIsIm9sZCIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsIm1lcmdlZCIsImV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsInByZXNlcnZlIiwic2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4iLCJpc1RleHROb2RlIiwibmVzdGVkSW5kZXgiLCJsYXN0SW5kZXgiLCJfaXNWTGlzdCIsImVuc3VyZUN0b3IiLCJjcmVhdGVBc3luY1BsYWNlaG9sZGVyIiwiZmFjdG9yeSIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImJhc2VDdG9yIiwiZXJyb3JDb21wIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwiY29udGV4dHMiLCJzeW5jIiwiZm9yY2VSZW5kZXIiLCJkZWxheSIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsImhvb2tSRSIsImkkMSIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsInNsb3QiLCJuYW1lJDEiLCJpc1doaXRlc3BhY2UiLCJyZXNvbHZlU2NvcGVkU2xvdHMiLCJhY3RpdmVJbnN0YW5jZSIsImlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCIsImluaXRMaWZlY3ljbGUiLCJhYnN0cmFjdCIsIiRjaGlsZHJlbiIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNNb3VudGVkIiwiX2lzRGVzdHJveWVkIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJsaWZlY3ljbGVNaXhpbiIsIl91cGRhdGUiLCJoeWRyYXRpbmciLCJjYWxsSG9vayIsInByZXZFbCIsIiRlbCIsInByZXZWbm9kZSIsIl92bm9kZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsIl9fcGF0Y2hfXyIsIl9wYXJlbnRFbG0iLCJfcmVmRWxtIiwiX192dWVfXyIsIiRkZXN0cm95IiwidGVhcmRvd24iLCJfd2F0Y2hlcnMiLCJfZGF0YSIsIm1vdW50Q29tcG9uZW50IiwidGVtcGxhdGUiLCJ1cGRhdGVDb21wb25lbnQiLCJfbmFtZSIsIl91aWQiLCJfcmVuZGVyIiwiV2F0Y2hlciIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwicGFyZW50Vm5vZGUiLCJyZW5kZXJDaGlsZHJlbiIsImhhc0NoaWxkcmVuIiwiX3JlbmRlckNoaWxkcmVuIiwic2NvcGVkU2xvdHMiLCIkc2NvcGVkU2xvdHMiLCIkYXR0cnMiLCIkbGlzdGVuZXJzIiwicHJvcEtleXMiLCJfcHJvcEtleXMiLCJpc0luSW5hY3RpdmVUcmVlIiwiYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImRpcmVjdCIsImRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsIk1BWF9VUERBVEVfQ09VTlQiLCJhY3RpdmF0ZWRDaGlsZHJlbiIsImNpcmN1bGFyIiwid2FpdGluZyIsImZsdXNoaW5nIiwicmVzZXRTY2hlZHVsZXJTdGF0ZSIsImZsdXNoU2NoZWR1bGVyUXVldWUiLCJ3YXRjaGVyIiwic29ydCIsInVzZXIiLCJleHByZXNzaW9uIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlZEhvb2tzIiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMiIsImV4cE9yRm4iLCJpc1JlbmRlcldhdGNoZXIiLCJsYXp5IiwiZGlydHkiLCJkZXBzIiwibmV3RGVwcyIsImRlcElkcyIsIm5ld0RlcElkcyIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiIsInByb3h5Iiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsImluaXRQcm9wcyIsImluaXRNZXRob2RzIiwiaW5pdERhdGEiLCJpbml0Q29tcHV0ZWQiLCJpbml0V2F0Y2giLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJsb29wIiwiaHlwaGVuYXRlZEtleSIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsImlzU1NSIiwidXNlckRlZiIsImRlZmluZUNvbXB1dGVkIiwiJGRhdGEiLCJzaG91bGRDYWNoZSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVXYXRjaGVyIiwia2V5T3JGbiIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJkYXRhRGVmIiwicHJvcHNEZWYiLCJuZXdEYXRhIiwiJHNldCIsIiRkZWxldGUiLCJpbW1lZGlhdGUiLCJ1bndhdGNoRm4iLCJpbml0UHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsInByb3ZpZGVLZXkiLCJwcm92aWRlRGVmYXVsdCIsInJlbmRlckxpc3QiLCJyZW5kZXJTbG90IiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsIm5vZGVzIiwic2xvdE5vZGVzIiwiX3JlbmRlcmVkIiwicmVzb2x2ZUZpbHRlciIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluQWxpYXMiLCJldmVudEtleU5hbWUiLCJiaW5kT2JqZWN0UHJvcHMiLCJhc1Byb3AiLCJpc1N5bmMiLCJkb21Qcm9wcyIsIiRldmVudCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImJpbmRPYmplY3RMaXN0ZW5lcnMiLCJvdXJzIiwiaW5zdGFsbFJlbmRlckhlbHBlcnMiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiX2ciLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsImluamVjdGlvbnMiLCJjb250ZXh0Vm0iLCJpc0NvbXBpbGVkIiwiX2NvbXBpbGVkIiwibmVlZE5vcm1hbGl6YXRpb24iLCJfc2NvcGVJZCIsIl9jIiwiZCIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwicmVuZGVyQ29udGV4dCIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJvbGRWbm9kZSIsImluc2VydCIsImRlc3Ryb3kiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJfYmFzZSIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwibmF0aXZlT24iLCJtZXJnZUhvb2tzIiwiX2lzQ29tcG9uZW50IiwiaW5saW5lVGVtcGxhdGUiLCJmcm9tUGFyZW50IiwibWVyZ2VIb29rJDEiLCJvbmUiLCJ0d28iLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsImFwcGx5TlMiLCJmb3JjZSIsImluaXRSZW5kZXIiLCJwYXJlbnREYXRhIiwicmVuZGVyTWl4aW4iLCJyZW5kZXJFcnJvciIsInVpZCQxIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsImV4dGVuZGVkIiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImRlZHVwZSIsIlZ1ZSQzIiwiaW5pdFVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsImluaXRNaXhpbiQxIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJkZWZpbml0aW9uIiwiZ2V0Q29tcG9uZW50TmFtZSIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjYWNoZWQkJDEiLCJwYXR0ZXJuVHlwZXMiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsInJlZiQxIiwicGFyc2VJbnQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJkZWxldGUiLCJzc3JDb250ZXh0IiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImlzRmFsc3lBdHRyVmFsdWUiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNUZXh0SW5wdXRUeXBlIiwic2VsZWN0ZWQiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJuYW1lc3BhY2UiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaXNVbmtub3duRWxlbWVudCQkMSIsImluVlByZSIsImlnbm9yZSIsImNyZWF0aW5nRWxtSW5WUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwibmVzdGVkIiwicHJlIiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiY2hlY2tEdXBsaWNhdGVLZXlzIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwic2VlbktleXMiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJoeWRyYXRpb25CYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImlubmVySFRNTCIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImZ1bGxJbnZva2UiLCJub2RlVHlwZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwicGFyZW50RWxtJDEiLCJfbGVhdmVDYiIsInBhdGNoYWJsZSIsImkkMiIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJjYWxsSG9vayQxIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlTlMiLCJfX2llcGgiLCJibG9ja2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwiZmlsdGVycyIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiYmFzZVdhcm4iLCJwbHVja01vZHVsZUZ1bmN0aW9uIiwiYWRkUHJvcCIsInBsYWluIiwiYWRkQXR0ciIsImFkZFJhd0F0dHIiLCJhdHRyc01hcCIsImF0dHJzTGlzdCIsImFkZERpcmVjdGl2ZSIsImFkZEhhbmRsZXIiLCJpbXBvcnRhbnQiLCJwcmV2ZW50IiwicmlnaHQiLCJtaWRkbGUiLCJldmVudHMiLCJuYXRpdmUiLCJuYXRpdmVFdmVudHMiLCJuZXdIYW5kbGVyIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJyZW1vdmVGcm9tTWFwIiwiZ2VuQ29tcG9uZW50TW9kZWwiLCJudW1iZXIiLCJiYXNlVmFsdWVFeHByZXNzaW9uIiwidmFsdWVFeHByZXNzaW9uIiwiYXNzaWdubWVudCIsImdlbkFzc2lnbm1lbnRDb2RlIiwicGFyc2VNb2RlbCIsImNociIsImluZGV4JDEiLCJleHByZXNzaW9uUG9zIiwiZXhwcmVzc2lvbkVuZFBvcyIsImxhc3RJbmRleE9mIiwiZW9mIiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0IiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJnZW5TZWxlY3QiLCJnZW5DaGVja2JveE1vZGVsIiwiZ2VuUmFkaW9Nb2RlbCIsImdlbkRlZmF1bHRNb2RlbCIsInZhbHVlQmluZGluZyIsInRydWVWYWx1ZUJpbmRpbmciLCJmYWxzZVZhbHVlQmluZGluZyIsInNlbGVjdGVkVmFsIiwiY29kZSIsInZhbHVlJDEiLCJuZWVkQ29tcG9zaXRpb25HdWFyZCIsIm5vcm1hbGl6ZUV2ZW50cyIsImNoYW5nZSIsInRhcmdldCQxIiwiY3JlYXRlT25jZUhhbmRsZXIiLCJvbmNlSGFuZGxlciIsInJlbW92ZSQyIiwiYWRkJDEiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJ1cGRhdGVET01Qcm9wcyIsIm9sZFByb3BzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzTm90SW5Gb2N1c0FuZERpcnR5IiwiaXNEaXJ0eVdpdGhNb2RpZmllcnMiLCJub3RJbkZvY3VzIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwic3R5bGUiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWQiLCJiZWZvcmVBcHBlYXIiLCJhcHBlYXIiLCJhZnRlckFwcGVhciIsImFwcGVhckNhbmNlbGxlZCIsImR1cmF0aW9uIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsInN0YXJ0Q2xhc3MiLCJ0b0NsYXNzIiwiYmVmb3JlRW50ZXJIb29rIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJlbnRlckNhbmNlbGxlZEhvb2siLCJleHBsaWNpdEVudGVyRHVyYXRpb24iLCJjaGVja0R1cmF0aW9uIiwiZXhwZWN0c0NTUyIsInVzZXJXYW50c0NvbnRyb2wiLCJnZXRIb29rQXJndW1lbnRzTGVuZ3RoIiwic2hvdyIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImJlZm9yZUxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImxlYXZlQ2FuY2VsbGVkIiwiZGVsYXlMZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsInBlcmZvcm1MZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJwbGF0Zm9ybU1vZHVsZXMiLCJ2bW9kZWwiLCJ0cmlnZ2VyIiwiZGlyZWN0aXZlIiwiX3ZPcHRpb25zIiwic2V0U2VsZWN0ZWQiLCJnZXRWYWx1ZSIsIm9uQ29tcG9zaXRpb25FbmQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJwcmV2T3B0aW9ucyIsImN1ck9wdGlvbnMiLCJvIiwibmVlZFJlc2V0IiwiaGFzTm9NYXRjaGluZ09wdGlvbiIsImFjdHVhbGx5U2V0U2VsZWN0ZWQiLCJpc011bHRpcGxlIiwib3B0aW9uIiwic2VsZWN0ZWRJbmRleCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImxvY2F0ZU5vZGUiLCJ0cmFuc2l0aW9uJCQxIiwib3JpZ2luYWxEaXNwbGF5IiwiX192T3JpZ2luYWxEaXNwbGF5IiwiZGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwicGxhY2Vob2xkZXIiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJiZWZvcmVVcGRhdGUiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJfcmVmbG93IiwiYm9keSIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJkeSIsInBsYXRmb3JtQ29tcG9uZW50cyIsImRlZmF1bHRUYWdSRSIsInJlZ2V4RXNjYXBlUkUiLCJidWlsZFJlZ2V4IiwiZGVsaW1pdGVycyIsIm9wZW4iLCJwYXJzZVRleHQiLCJ0YWdSRSIsInJhd1Rva2VucyIsInRva2VuVmFsdWUiLCJ0cmFuc2Zvcm1Ob2RlIiwiY2xhc3NCaW5kaW5nIiwiZ2VuRGF0YSIsImtsYXNzJDEiLCJ0cmFuc2Zvcm1Ob2RlJDEiLCJzdHlsZUJpbmRpbmciLCJnZW5EYXRhJDEiLCJzdHlsZSQxIiwiZGVjb2RlciIsImhlIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiIsImciLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiaXNJZ25vcmVOZXdsaW5lVGFnIiwic2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lIiwiZGVjb2RlQXR0ciIsInNob3VsZERlY29kZU5ld2xpbmVzIiwicGFyc2VIVE1MIiwiZXhwZWN0SFRNTCIsImlzVW5hcnlUYWckJDEiLCJjYW5CZUxlZnRPcGVuVGFnJCQxIiwibGFzdFRhZyIsInRleHRFbmQiLCJjb21tZW50RW5kIiwic2hvdWxkS2VlcENvbW1lbnQiLCJzdWJzdHJpbmciLCJhZHZhbmNlIiwiY29uZGl0aW9uYWxFbmQiLCJkb2N0eXBlTWF0Y2giLCJlbmRUYWdNYXRjaCIsImN1ckluZGV4IiwicGFyc2VFbmRUYWciLCJzdGFydFRhZ01hdGNoIiwicGFyc2VTdGFydFRhZyIsImhhbmRsZVN0YXJ0VGFnIiwicmVzdCIsImNoYXJzIiwiZW5kVGFnTGVuZ3RoIiwic3RhY2tlZFRhZyIsInJlU3RhY2tlZFRhZyIsInJlc3QkMSIsImFsbCIsInVuYXJ5U2xhc2giLCJ1bmFyeSIsInNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiIsImxvd2VyQ2FzZWRUYWciLCJsb3dlckNhc2VkVGFnTmFtZSIsIm9uUkUiLCJkaXJSRSIsImZvckFsaWFzUkUiLCJmb3JJdGVyYXRvclJFIiwic3RyaXBQYXJlbnNSRSIsImFyZ1JFIiwiYmluZFJFIiwibW9kaWZpZXJSRSIsImRlY29kZUhUTUxDYWNoZWQiLCJ3YXJuJDIiLCJ0cmFuc2Zvcm1zIiwicHJlVHJhbnNmb3JtcyIsInBvc3RUcmFuc2Zvcm1zIiwicGxhdGZvcm1Jc1ByZVRhZyIsInBsYXRmb3JtTXVzdFVzZVByb3AiLCJwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSIsImNyZWF0ZUFTVEVsZW1lbnQiLCJtYWtlQXR0cnNNYXAiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluUHJlIiwid2FybmVkIiwid2Fybk9uY2UiLCJjbG9zZUVsZW1lbnQiLCJlbGVtZW50IiwiY29tbWVudHMiLCJndWFyZElFU1ZHQnVnIiwiaXNGb3JiaWRkZW5UYWciLCJmb3JiaWRkZW4iLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc2VkIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwicHJvY2Vzc0VsZW1lbnQiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImlmIiwiZWxzZWlmIiwiZWxzZSIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwic2xvdFRhcmdldCIsImxhc3ROb2RlIiwiaXNUZXh0VGFnIiwicHJvY2Vzc0tleSIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJjaGVja0luRm9yIiwicGFyc2VGb3IiLCJpbk1hdGNoIiwiZm9yIiwiaXRlcmF0b3JNYXRjaCIsIml0ZXJhdG9yMSIsIml0ZXJhdG9yMiIsImZpbmRQcmV2RWxlbWVudCIsImlmQ29uZGl0aW9ucyIsInNsb3ROYW1lIiwiaXNQcm9wIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsInByZVRyYW5zZm9ybU5vZGUiLCJ0eXBlQmluZGluZyIsImlmQ29uZGl0aW9uIiwiaWZDb25kaXRpb25FeHRyYSIsImhhc0Vsc2UiLCJlbHNlSWZDb25kaXRpb24iLCJicmFuY2gwIiwiY2xvbmVBU1RFbGVtZW50IiwiYnJhbmNoMSIsImJyYW5jaDIiLCJtb2RlbCQyIiwibW9kdWxlcyQxIiwiZGlyZWN0aXZlcyQxIiwiYmFzZU9wdGlvbnMiLCJpc1N0YXRpY0tleSIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyIsImdlblN0YXRpY0tleXNDYWNoZWQiLCJnZW5TdGF0aWNLZXlzJDEiLCJvcHRpbWl6ZSIsIm1hcmtTdGF0aWMkMSIsIm1hcmtTdGF0aWNSb290cyIsInN0YXRpYyIsImwkMSIsInN0YXRpY0luRm9yIiwic3RhdGljUm9vdCIsImlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIiwiZm5FeHBSRSIsInNpbXBsZVBhdGhSRSIsImVzYyIsInRhYiIsInNwYWNlIiwidXAiLCJkb3duIiwiZ2VuR3VhcmQiLCJtb2RpZmllckNvZGUiLCJzdG9wIiwiY3RybCIsImFsdCIsImdlbkhhbmRsZXJzIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwia2V5TW9kaWZpZXIiLCJnZW5LZXlGaWx0ZXIiLCJoYW5kbGVyQ29kZSIsImdlbkZpbHRlckNvZGUiLCJrZXlWYWwiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm1heWJlQ29tcG9uZW50Iiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSQyIiwiYWx0R2VuIiwiYWx0RW1wdHkiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsImFsdEhlbHBlciIsImdlbkRpcmVjdGl2ZXMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJoYXNSdW50aW1lIiwibmVlZFJ1bnRpbWUiLCJnZW4iLCJpbmxpbmVSZW5kZXJGbnMiLCJnZW5TY29wZWRTbG90IiwiZ2VuRm9yU2NvcGVkU2xvdCIsImNoZWNrU2tpcCIsImFsdEdlbkVsZW1lbnQiLCJhbHRHZW5Ob2RlIiwiZWwkMSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlbkNvbW1lbnQiLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwidW5hcnlPcGVyYXRvcnNSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJlcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJzdGlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJjcmVhdGVGdW5jdGlvbiIsImNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4iLCJjb21waWxlVG9GdW5jdGlvbnMiLCJ3YXJuJCQxIiwiY29tcGlsZWQiLCJ0aXBzIiwiZm5HZW5FcnJvcnMiLCJjcmVhdGVDb21waWxlckNyZWF0b3IiLCJiYXNlQ29tcGlsZSIsImNyZWF0ZUNvbXBpbGVyIiwiZmluYWxPcHRpb25zIiwiZGl2IiwiZ2V0U2hvdWxkRGVjb2RlIiwiaWRUb1RlbXBsYXRlIiwibW91bnQiLCJnZXRPdXRlckhUTUwiLCJvdXRlckhUTUwiLCJjb250YWluZXIiLCJldmFsIiwiUm91dGVyQ29uZmlnIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUEyRDtBQUMzRDtBQUNBO0FBQ0EsV0FBRzs7QUFFSCxvREFBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGVBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7Ozs7QUFJQTtBQUNBLHNEQUE4QztBQUM5QztBQUNBO0FBQ0Esb0NBQTRCO0FBQzVCLHFDQUE2QjtBQUM3Qix5Q0FBaUM7O0FBRWpDLCtDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBc0M7QUFDdEM7QUFDQTtBQUNBLHFDQUE2QjtBQUM3QixxQ0FBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7O0FBRUEsNERBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNCQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBZ0IsdUNB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TTR6QyxlQUFlO0FBQ2pCeGdEO0FBRGlCLENBQXJCO0FBR0EsSUFBTXRLLFNBQVMsd0JBQWM4cUQsWUFBZCxDQUFmOztBQUVBLGtCQUFRO0FBQ0pwOEMsUUFBSSxPQURBO0FBRUoxTyxZQUFRQSxNQUZKO0FBR0psSCxZQUFRO0FBQUEsZUFBS0MsZ0JBQUw7QUFBQTtBQUhKLENBQVIsRTs7Ozs7Ozs7OztBQ2JBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7QUFFQSxjQUFJbWUsR0FBSjs7QUFFQSxJQUFNNHpDLGVBQWU7QUFDakJ4Z0Q7QUFEaUIsQ0FBckI7QUFHQSxJQUFNdEssU0FBUyx3QkFBYzhxRCxZQUFkLENBQWY7O0FBRUEsa0JBQVE7QUFDSnA4QyxRQUFJLE9BREE7QUFFSjFPLFlBQVFBLE1BRko7QUFHSmxILFlBQVE7QUFBQSxlQUFLQyxnQkFBTDtBQUFBO0FBSEosQ0FBUixFIiwiZmlsZSI6Im1haW4uYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0ZnVuY3Rpb24gaG90RGlzcG9zZUNodW5rKGNodW5rSWQpIHtcbiBcdFx0ZGVsZXRlIGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcbiBcdH1cbiBcdHZhciBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayA9IHdpbmRvd1tcIndlYnBhY2tIb3RVcGRhdGVcIl07XG4gXHR3aW5kb3dbXCJ3ZWJwYWNrSG90VXBkYXRlXCJdID0gXHJcbiBcdGZ1bmN0aW9uIHdlYnBhY2tIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0aG90QWRkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgbW9yZU1vZHVsZXMpO1xyXG4gXHRcdGlmKHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrKSBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcyk7XHJcbiBcdH0gO1xyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRVcGRhdGVDaHVuayhjaHVua0lkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuIFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcclxuIFx0XHRzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XHJcbiBcdFx0c2NyaXB0LmNoYXJzZXQgPSBcInV0Zi04XCI7XHJcbiBcdFx0c2NyaXB0LnNyYyA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyBjaHVua0lkICsgXCIuXCIgKyBob3RDdXJyZW50SGFzaCArIFwiLmhvdC11cGRhdGUuanNcIjtcclxuIFx0XHQ7XHJcbiBcdFx0aGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3REb3dubG9hZE1hbmlmZXN0KHJlcXVlc3RUaW1lb3V0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHRyZXF1ZXN0VGltZW91dCA9IHJlcXVlc3RUaW1lb3V0IHx8IDEwMDAwO1xyXG4gXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuIFx0XHRcdGlmKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gXCJ1bmRlZmluZWRcIilcclxuIFx0XHRcdFx0cmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJObyBicm93c2VyIHN1cHBvcnRcIikpO1xyXG4gXHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuIFx0XHRcdFx0dmFyIHJlcXVlc3RQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGhvdEN1cnJlbnRIYXNoICsgXCIuaG90LXVwZGF0ZS5qc29uXCI7XHJcbiBcdFx0XHRcdHJlcXVlc3Qub3BlbihcIkdFVFwiLCByZXF1ZXN0UGF0aCwgdHJ1ZSk7XHJcbiBcdFx0XHRcdHJlcXVlc3QudGltZW91dCA9IHJlcXVlc3RUaW1lb3V0O1xyXG4gXHRcdFx0XHRyZXF1ZXN0LnNlbmQobnVsbCk7XHJcbiBcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRyZXR1cm4gcmVqZWN0KGVycik7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRyZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gXHRcdFx0XHRpZihyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcclxuIFx0XHRcdFx0aWYocmVxdWVzdC5zdGF0dXMgPT09IDApIHtcclxuIFx0XHRcdFx0XHQvLyB0aW1lb3V0XHJcbiBcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIHRpbWVkIG91dC5cIikpO1xyXG4gXHRcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgPT09IDQwNCkge1xyXG4gXHRcdFx0XHRcdC8vIG5vIHVwZGF0ZSBhdmFpbGFibGVcclxuIFx0XHRcdFx0XHRyZXNvbHZlKCk7XHJcbiBcdFx0XHRcdH0gZWxzZSBpZihyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwICYmIHJlcXVlc3Quc3RhdHVzICE9PSAzMDQpIHtcclxuIFx0XHRcdFx0XHQvLyBvdGhlciBmYWlsdXJlXHJcbiBcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIGZhaWxlZC5cIikpO1xyXG4gXHRcdFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0XHRcdC8vIHN1Y2Nlc3NcclxuIFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0dmFyIHVwZGF0ZSA9IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG4gXHRcdFx0XHRcdH0gY2F0Y2goZSkge1xyXG4gXHRcdFx0XHRcdFx0cmVqZWN0KGUpO1xyXG4gXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRyZXNvbHZlKHVwZGF0ZSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH07XHJcbiBcdFx0fSk7XHJcbiBcdH1cclxuXG4gXHRcclxuIFx0XHJcbiBcdHZhciBob3RBcHBseU9uVXBkYXRlID0gdHJ1ZTtcclxuIFx0dmFyIGhvdEN1cnJlbnRIYXNoID0gXCI1MjE3YTVhMTAzY2Q2OWIzMGRhOVwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdHZhciBob3RSZXF1ZXN0VGltZW91dCA9IDEwMDAwO1xyXG4gXHR2YXIgaG90Q3VycmVudE1vZHVsZURhdGEgPSB7fTtcclxuIFx0dmFyIGhvdEN1cnJlbnRDaGlsZE1vZHVsZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHNUZW1wID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHZhciBtZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdGlmKCFtZSkgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX187XHJcbiBcdFx0dmFyIGZuID0gZnVuY3Rpb24ocmVxdWVzdCkge1xyXG4gXHRcdFx0aWYobWUuaG90LmFjdGl2ZSkge1xyXG4gXHRcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdKSB7XHJcbiBcdFx0XHRcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XS5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpIDwgMClcclxuIFx0XHRcdFx0XHRcdGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0aG90Q3VycmVudENoaWxkTW9kdWxlID0gcmVxdWVzdDtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihtZS5jaGlsZHJlbi5pbmRleE9mKHJlcXVlc3QpIDwgMClcclxuIFx0XHRcdFx0XHRtZS5jaGlsZHJlbi5wdXNoKHJlcXVlc3QpO1xyXG4gXHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVxdWVzdCArIFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArIG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbXTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHJlcXVlc3QpO1xyXG4gXHRcdH07XHJcbiBcdFx0dmFyIE9iamVjdEZhY3RvcnkgPSBmdW5jdGlvbiBPYmplY3RGYWN0b3J5KG5hbWUpIHtcclxuIFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXTtcclxuIFx0XHRcdFx0fSxcclxuIFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX19bbmFtZV0gPSB2YWx1ZTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fTtcclxuIFx0XHR9O1xyXG4gXHRcdGZvcih2YXIgbmFtZSBpbiBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX193ZWJwYWNrX3JlcXVpcmVfXywgbmFtZSkgJiYgbmFtZSAhPT0gXCJlXCIpIHtcclxuIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBuYW1lLCBPYmplY3RGYWN0b3J5KG5hbWUpKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFx0Zm4uZSA9IGZ1bmN0aW9uKGNodW5rSWQpIHtcclxuIFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJyZWFkeVwiKVxyXG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xyXG4gXHRcdFx0aG90Q2h1bmtzTG9hZGluZysrO1xyXG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZShjaHVua0lkKS50aGVuKGZpbmlzaENodW5rTG9hZGluZywgZnVuY3Rpb24oZXJyKSB7XHJcbiBcdFx0XHRcdGZpbmlzaENodW5rTG9hZGluZygpO1xyXG4gXHRcdFx0XHR0aHJvdyBlcnI7XHJcbiBcdFx0XHR9KTtcclxuIFx0XHJcbiBcdFx0XHRmdW5jdGlvbiBmaW5pc2hDaHVua0xvYWRpbmcoKSB7XHJcbiBcdFx0XHRcdGhvdENodW5rc0xvYWRpbmctLTtcclxuIFx0XHRcdFx0aWYoaG90U3RhdHVzID09PSBcInByZXBhcmVcIikge1xyXG4gXHRcdFx0XHRcdGlmKCFob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0pIHtcclxuIFx0XHRcdFx0XHRcdGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRpZihob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xyXG4gXHRcdFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH07XHJcbiBcdFx0cmV0dXJuIGZuO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHZhciBob3QgPSB7XHJcbiBcdFx0XHQvLyBwcml2YXRlIHN0dWZmXHJcbiBcdFx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxyXG4gXHRcdFx0X2RlY2xpbmVkRGVwZW5kZW5jaWVzOiB7fSxcclxuIFx0XHRcdF9zZWxmQWNjZXB0ZWQ6IGZhbHNlLFxyXG4gXHRcdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXHJcbiBcdFx0XHRfZGlzcG9zZUhhbmRsZXJzOiBbXSxcclxuIFx0XHRcdF9tYWluOiBob3RDdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkLFxyXG4gXHRcclxuIFx0XHRcdC8vIE1vZHVsZSBBUElcclxuIFx0XHRcdGFjdGl2ZTogdHJ1ZSxcclxuIFx0XHRcdGFjY2VwdDogZnVuY3Rpb24oZGVwLCBjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgZGVwID09PSBcInVuZGVmaW5lZFwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkFjY2VwdGVkID0gdHJ1ZTtcclxuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpXHJcbiBcdFx0XHRcdFx0aG90Ll9zZWxmQWNjZXB0ZWQgPSBkZXA7XHJcbiBcdFx0XHRcdGVsc2UgaWYodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIilcclxuIFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxyXG4gXHRcdFx0XHRcdFx0aG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBbaV1dID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuIFx0XHRcdFx0ZWxzZVxyXG4gXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0ZGVjbGluZTogZnVuY3Rpb24oZGVwKSB7XHJcbiBcdFx0XHRcdGlmKHR5cGVvZiBkZXAgPT09IFwidW5kZWZpbmVkXCIpXHJcbiBcdFx0XHRcdFx0aG90Ll9zZWxmRGVjbGluZWQgPSB0cnVlO1xyXG4gXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpXHJcbiBcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKylcclxuIFx0XHRcdFx0XHRcdGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IHRydWU7XHJcbiBcdFx0XHRcdGVsc2VcclxuIFx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcF0gPSB0cnVlO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGRpc3Bvc2U6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGFkZERpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRyZW1vdmVEaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdC5fZGlzcG9zZUhhbmRsZXJzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gXHRcdFx0XHRpZihpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcclxuIFx0XHRcdC8vIE1hbmFnZW1lbnQgQVBJXHJcbiBcdFx0XHRjaGVjazogaG90Q2hlY2ssXHJcbiBcdFx0XHRhcHBseTogaG90QXBwbHksXHJcbiBcdFx0XHRzdGF0dXM6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0aWYoIWwpIHJldHVybiBob3RTdGF0dXM7XHJcbiBcdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0YWRkU3RhdHVzSGFuZGxlcjogZnVuY3Rpb24obCkge1xyXG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdHJlbW92ZVN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XHJcbiBcdFx0XHRcdGlmKGlkeCA+PSAwKSBob3RTdGF0dXNIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcclxuIFx0XHRcdH0sXHJcbiBcdFxyXG4gXHRcdFx0Ly9pbmhlcml0IGZyb20gcHJldmlvdXMgZGlzcG9zZSBjYWxsXHJcbiBcdFx0XHRkYXRhOiBob3RDdXJyZW50TW9kdWxlRGF0YVttb2R1bGVJZF1cclxuIFx0XHR9O1xyXG4gXHRcdGhvdEN1cnJlbnRDaGlsZE1vZHVsZSA9IHVuZGVmaW5lZDtcclxuIFx0XHRyZXR1cm4gaG90O1xyXG4gXHR9XHJcbiBcdFxyXG4gXHR2YXIgaG90U3RhdHVzSGFuZGxlcnMgPSBbXTtcclxuIFx0dmFyIGhvdFN0YXR1cyA9IFwiaWRsZVwiO1xyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90U2V0U3RhdHVzKG5ld1N0YXR1cykge1xyXG4gXHRcdGhvdFN0YXR1cyA9IG5ld1N0YXR1cztcclxuIFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaG90U3RhdHVzSGFuZGxlcnMubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRob3RTdGF0dXNIYW5kbGVyc1tpXS5jYWxsKG51bGwsIG5ld1N0YXR1cyk7XHJcbiBcdH1cclxuIFx0XHJcbiBcdC8vIHdoaWxlIGRvd25sb2FkaW5nXHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXMgPSAwO1xyXG4gXHR2YXIgaG90Q2h1bmtzTG9hZGluZyA9IDA7XHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXNNYXAgPSB7fTtcclxuIFx0dmFyIGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XHJcbiBcdHZhciBob3RBdmFpbGFibGVGaWxlc01hcCA9IHt9O1xyXG4gXHR2YXIgaG90RGVmZXJyZWQ7XHJcbiBcdFxyXG4gXHQvLyBUaGUgdXBkYXRlIGluZm9cclxuIFx0dmFyIGhvdFVwZGF0ZSwgaG90VXBkYXRlTmV3SGFzaDtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIHRvTW9kdWxlSWQoaWQpIHtcclxuIFx0XHR2YXIgaXNOdW1iZXIgPSAoK2lkKSArIFwiXCIgPT09IGlkO1xyXG4gXHRcdHJldHVybiBpc051bWJlciA/ICtpZCA6IGlkO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDaGVjayhhcHBseSkge1xyXG4gXHRcdGlmKGhvdFN0YXR1cyAhPT0gXCJpZGxlXCIpIHRocm93IG5ldyBFcnJvcihcImNoZWNrKCkgaXMgb25seSBhbGxvd2VkIGluIGlkbGUgc3RhdHVzXCIpO1xyXG4gXHRcdGhvdEFwcGx5T25VcGRhdGUgPSBhcHBseTtcclxuIFx0XHRob3RTZXRTdGF0dXMoXCJjaGVja1wiKTtcclxuIFx0XHRyZXR1cm4gaG90RG93bmxvYWRNYW5pZmVzdChob3RSZXF1ZXN0VGltZW91dCkudGhlbihmdW5jdGlvbih1cGRhdGUpIHtcclxuIFx0XHRcdGlmKCF1cGRhdGUpIHtcclxuIFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcclxuIFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xyXG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwID0ge307XHJcbiBcdFx0XHRob3RBdmFpbGFibGVGaWxlc01hcCA9IHVwZGF0ZS5jO1xyXG4gXHRcdFx0aG90VXBkYXRlTmV3SGFzaCA9IHVwZGF0ZS5oO1xyXG4gXHRcclxuIFx0XHRcdGhvdFNldFN0YXR1cyhcInByZXBhcmVcIik7XHJcbiBcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gXHRcdFx0XHRob3REZWZlcnJlZCA9IHtcclxuIFx0XHRcdFx0XHRyZXNvbHZlOiByZXNvbHZlLFxyXG4gXHRcdFx0XHRcdHJlamVjdDogcmVqZWN0XHJcbiBcdFx0XHRcdH07XHJcbiBcdFx0XHR9KTtcclxuIFx0XHRcdGhvdFVwZGF0ZSA9IHt9O1xyXG4gXHRcdFx0dmFyIGNodW5rSWQgPSAwO1xyXG4gXHRcdFx0eyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvbmUtYmxvY2tzXHJcbiBcdFx0XHRcdC8qZ2xvYmFscyBjaHVua0lkICovXHJcbiBcdFx0XHRcdGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0aWYoaG90U3RhdHVzID09PSBcInByZXBhcmVcIiAmJiBob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xyXG4gXHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRyZXR1cm4gcHJvbWlzZTtcclxuIFx0XHR9KTtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90QWRkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgbW9yZU1vZHVsZXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdGlmKCFob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSB8fCAhaG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0pXHJcbiBcdFx0XHRyZXR1cm47XHJcbiBcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0gPSBmYWxzZTtcclxuIFx0XHRmb3IodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRob3RVcGRhdGVbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHRpZigtLWhvdFdhaXRpbmdGaWxlcyA9PT0gMCAmJiBob3RDaHVua3NMb2FkaW5nID09PSAwKSB7XHJcbiBcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcbiBcdFx0fVxyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKSB7XHJcbiBcdFx0aWYoIWhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdKSB7XHJcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xyXG4gXHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSA9IHRydWU7XHJcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXMrKztcclxuIFx0XHRcdGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XHJcbiBcdFx0fVxyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RVcGRhdGVEb3dubG9hZGVkKCkge1xyXG4gXHRcdGhvdFNldFN0YXR1cyhcInJlYWR5XCIpO1xyXG4gXHRcdHZhciBkZWZlcnJlZCA9IGhvdERlZmVycmVkO1xyXG4gXHRcdGhvdERlZmVycmVkID0gbnVsbDtcclxuIFx0XHRpZighZGVmZXJyZWQpIHJldHVybjtcclxuIFx0XHRpZihob3RBcHBseU9uVXBkYXRlKSB7XHJcbiBcdFx0XHQvLyBXcmFwIGRlZmVycmVkIG9iamVjdCBpbiBQcm9taXNlIHRvIG1hcmsgaXQgYXMgYSB3ZWxsLWhhbmRsZWQgUHJvbWlzZSB0b1xyXG4gXHRcdFx0Ly8gYXZvaWQgdHJpZ2dlcmluZyB1bmNhdWdodCBleGNlcHRpb24gd2FybmluZyBpbiBDaHJvbWUuXHJcbiBcdFx0XHQvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDY1NjY2XHJcbiBcdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gXHRcdFx0XHRyZXR1cm4gaG90QXBwbHkoaG90QXBwbHlPblVwZGF0ZSk7XHJcbiBcdFx0XHR9KS50aGVuKFxyXG4gXHRcdFx0XHRmdW5jdGlvbihyZXN1bHQpIHtcclxuIFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XHJcbiBcdFx0XHRcdH0sXHJcbiBcdFx0XHRcdGZ1bmN0aW9uKGVycikge1xyXG4gXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdChlcnIpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHQpO1xyXG4gXHRcdH0gZWxzZSB7XHJcbiBcdFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XHJcbiBcdFx0XHRmb3IodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xyXG4gXHRcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaG90VXBkYXRlLCBpZCkpIHtcclxuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaCh0b01vZHVsZUlkKGlkKSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHRcdGRlZmVycmVkLnJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHR9XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdEFwcGx5KG9wdGlvbnMpIHtcclxuIFx0XHRpZihob3RTdGF0dXMgIT09IFwicmVhZHlcIikgdGhyb3cgbmV3IEVycm9yKFwiYXBwbHkoKSBpcyBvbmx5IGFsbG93ZWQgaW4gcmVhZHkgc3RhdHVzXCIpO1xyXG4gXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gXHRcclxuIFx0XHR2YXIgY2I7XHJcbiBcdFx0dmFyIGk7XHJcbiBcdFx0dmFyIGo7XHJcbiBcdFx0dmFyIG1vZHVsZTtcclxuIFx0XHR2YXIgbW9kdWxlSWQ7XHJcbiBcdFxyXG4gXHRcdGZ1bmN0aW9uIGdldEFmZmVjdGVkU3R1ZmYodXBkYXRlTW9kdWxlSWQpIHtcclxuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbdXBkYXRlTW9kdWxlSWRdO1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XHJcbiBcdFxyXG4gXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCkubWFwKGZ1bmN0aW9uKGlkKSB7XHJcbiBcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0Y2hhaW46IFtpZF0sXHJcbiBcdFx0XHRcdFx0aWQ6IGlkXHJcbiBcdFx0XHRcdH07XHJcbiBcdFx0XHR9KTtcclxuIFx0XHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuIFx0XHRcdFx0dmFyIHF1ZXVlSXRlbSA9IHF1ZXVlLnBvcCgpO1xyXG4gXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZUl0ZW0uaWQ7XHJcbiBcdFx0XHRcdHZhciBjaGFpbiA9IHF1ZXVlSXRlbS5jaGFpbjtcclxuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdGlmKCFtb2R1bGUgfHwgbW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRpZihtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWRlY2xpbmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKG1vZHVsZS5ob3QuX21haW4pIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdFx0dHlwZTogXCJ1bmFjY2VwdGVkXCIsXHJcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtb2R1bGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHRcdHZhciBwYXJlbnRJZCA9IG1vZHVsZS5wYXJlbnRzW2ldO1xyXG4gXHRcdFx0XHRcdHZhciBwYXJlbnQgPSBpbnN0YWxsZWRNb2R1bGVzW3BhcmVudElkXTtcclxuIFx0XHRcdFx0XHRpZighcGFyZW50KSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRpZihwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcclxuIFx0XHRcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZGVjbGluZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcclxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRwYXJlbnRJZDogcGFyZW50SWRcclxuIFx0XHRcdFx0XHRcdH07XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGlmKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSA+PSAwKSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRpZihwYXJlbnQuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcclxuIFx0XHRcdFx0XHRcdGlmKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXHJcbiBcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSA9IFtdO1xyXG4gXHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdLCBbbW9kdWxlSWRdKTtcclxuIFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdO1xyXG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcclxuIFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHtcclxuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXHJcbiBcdFx0XHRcdFx0XHRpZDogcGFyZW50SWRcclxuIFx0XHRcdFx0XHR9KTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcclxuIFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdHR5cGU6IFwiYWNjZXB0ZWRcIixcclxuIFx0XHRcdFx0bW9kdWxlSWQ6IHVwZGF0ZU1vZHVsZUlkLFxyXG4gXHRcdFx0XHRvdXRkYXRlZE1vZHVsZXM6IG91dGRhdGVkTW9kdWxlcyxcclxuIFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXM6IG91dGRhdGVkRGVwZW5kZW5jaWVzXHJcbiBcdFx0XHR9O1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0ZnVuY3Rpb24gYWRkQWxsVG9TZXQoYSwgYikge1xyXG4gXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0dmFyIGl0ZW0gPSBiW2ldO1xyXG4gXHRcdFx0XHRpZihhLmluZGV4T2YoaXRlbSkgPCAwKVxyXG4gXHRcdFx0XHRcdGEucHVzaChpdGVtKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIGF0IGJlZ2luIGFsbCB1cGRhdGVzIG1vZHVsZXMgYXJlIG91dGRhdGVkXHJcbiBcdFx0Ly8gdGhlIFwib3V0ZGF0ZWRcIiBzdGF0dXMgY2FuIHByb3BhZ2F0ZSB0byBwYXJlbnRzIGlmIHRoZXkgZG9uJ3QgYWNjZXB0IHRoZSBjaGlsZHJlblxyXG4gXHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xyXG4gXHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcclxuIFx0XHR2YXIgYXBwbGllZFVwZGF0ZSA9IHt9O1xyXG4gXHRcclxuIFx0XHR2YXIgd2FyblVuZXhwZWN0ZWRSZXF1aXJlID0gZnVuY3Rpb24gd2FyblVuZXhwZWN0ZWRSZXF1aXJlKCkge1xyXG4gXHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVzdWx0Lm1vZHVsZUlkICsgXCIpIHRvIGRpc3Bvc2VkIG1vZHVsZVwiKTtcclxuIFx0XHR9O1xyXG4gXHRcclxuIFx0XHRmb3IodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZUlkID0gdG9Nb2R1bGVJZChpZCk7XHJcbiBcdFx0XHRcdHZhciByZXN1bHQ7XHJcbiBcdFx0XHRcdGlmKGhvdFVwZGF0ZVtpZF0pIHtcclxuIFx0XHRcdFx0XHRyZXN1bHQgPSBnZXRBZmZlY3RlZFN0dWZmKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRyZXN1bHQgPSB7XHJcbiBcdFx0XHRcdFx0XHR0eXBlOiBcImRpc3Bvc2VkXCIsXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogaWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdHZhciBhYm9ydEVycm9yID0gZmFsc2U7XHJcbiBcdFx0XHRcdHZhciBkb0FwcGx5ID0gZmFsc2U7XHJcbiBcdFx0XHRcdHZhciBkb0Rpc3Bvc2UgPSBmYWxzZTtcclxuIFx0XHRcdFx0dmFyIGNoYWluSW5mbyA9IFwiXCI7XHJcbiBcdFx0XHRcdGlmKHJlc3VsdC5jaGFpbikge1xyXG4gXHRcdFx0XHRcdGNoYWluSW5mbyA9IFwiXFxuVXBkYXRlIHByb3BhZ2F0aW9uOiBcIiArIHJlc3VsdC5jaGFpbi5qb2luKFwiIC0+IFwiKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRzd2l0Y2gocmVzdWx0LnR5cGUpIHtcclxuIFx0XHRcdFx0XHRjYXNlIFwic2VsZi1kZWNsaW5lZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkRlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIG9mIHNlbGYgZGVjbGluZTogXCIgKyByZXN1bHQubW9kdWxlSWQgKyBjaGFpbkluZm8pO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcImRlY2xpbmVkXCI6XHJcbiBcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRGVjbGluZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xyXG4gXHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXHJcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXCJBYm9ydGVkIGJlY2F1c2Ugb2YgZGVjbGluZWQgZGVwZW5kZW5jeTogXCIgKyByZXN1bHQubW9kdWxlSWQgKyBcIiBpbiBcIiArIHJlc3VsdC5wYXJlbnRJZCArIGNoYWluSW5mbyk7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwidW5hY2NlcHRlZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vblVuYWNjZXB0ZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25VbmFjY2VwdGVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVVbmFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIiArIGNoYWluSW5mbyk7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwiYWNjZXB0ZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25BY2NlcHRlZClcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkFjY2VwdGVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRkb0FwcGx5ID0gdHJ1ZTtcclxuIFx0XHRcdFx0XHRcdGJyZWFrO1xyXG4gXHRcdFx0XHRcdGNhc2UgXCJkaXNwb3NlZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkRpc3Bvc2VkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRGlzcG9zZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGRvRGlzcG9zZSA9IHRydWU7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRkZWZhdWx0OlxyXG4gXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leGNlcHRpb24gdHlwZSBcIiArIHJlc3VsdC50eXBlKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihhYm9ydEVycm9yKSB7XHJcbiBcdFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiYWJvcnRcIik7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGFib3J0RXJyb3IpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKGRvQXBwbHkpIHtcclxuIFx0XHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IGhvdFVwZGF0ZVttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCByZXN1bHQub3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHRcdFx0XHRmb3IobW9kdWxlSWQgaW4gcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XHJcbiBcdFx0XHRcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcclxuIFx0XHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0gPSBbXTtcclxuIFx0XHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdLCByZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKTtcclxuIFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYoZG9EaXNwb3NlKSB7XHJcbiBcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCBbcmVzdWx0Lm1vZHVsZUlkXSk7XHJcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSB3YXJuVW5leHBlY3RlZFJlcXVpcmU7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIFN0b3JlIHNlbGYgYWNjZXB0ZWQgb3V0ZGF0ZWQgbW9kdWxlcyB0byByZXF1aXJlIHRoZW0gbGF0ZXIgYnkgdGhlIG1vZHVsZSBzeXN0ZW1cclxuIFx0XHR2YXIgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzID0gW107XHJcbiBcdFx0Zm9yKGkgPSAwOyBpIDwgb3V0ZGF0ZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRtb2R1bGVJZCA9IG91dGRhdGVkTW9kdWxlc1tpXTtcclxuIFx0XHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdICYmIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkKVxyXG4gXHRcdFx0XHRvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMucHVzaCh7XHJcbiBcdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRlcnJvckhhbmRsZXI6IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkXHJcbiBcdFx0XHRcdH0pO1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gTm93IGluIFwiZGlzcG9zZVwiIHBoYXNlXHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiZGlzcG9zZVwiKTtcclxuIFx0XHRPYmplY3Qua2V5cyhob3RBdmFpbGFibGVGaWxlc01hcCkuZm9yRWFjaChmdW5jdGlvbihjaHVua0lkKSB7XHJcbiBcdFx0XHRpZihob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSA9PT0gZmFsc2UpIHtcclxuIFx0XHRcdFx0aG90RGlzcG9zZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH0pO1xyXG4gXHRcclxuIFx0XHR2YXIgaWR4O1xyXG4gXHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpO1xyXG4gXHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuIFx0XHRcdG1vZHVsZUlkID0gcXVldWUucG9wKCk7XHJcbiBcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdGlmKCFtb2R1bGUpIGNvbnRpbnVlO1xyXG4gXHRcclxuIFx0XHRcdHZhciBkYXRhID0ge307XHJcbiBcdFxyXG4gXHRcdFx0Ly8gQ2FsbCBkaXNwb3NlIGhhbmRsZXJzXHJcbiBcdFx0XHR2YXIgZGlzcG9zZUhhbmRsZXJzID0gbW9kdWxlLmhvdC5fZGlzcG9zZUhhbmRsZXJzO1xyXG4gXHRcdFx0Zm9yKGogPSAwOyBqIDwgZGlzcG9zZUhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XHJcbiBcdFx0XHRcdGNiID0gZGlzcG9zZUhhbmRsZXJzW2pdO1xyXG4gXHRcdFx0XHRjYihkYXRhKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXSA9IGRhdGE7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gZGlzYWJsZSBtb2R1bGUgKHRoaXMgZGlzYWJsZXMgcmVxdWlyZXMgZnJvbSB0aGlzIG1vZHVsZSlcclxuIFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gcmVtb3ZlIG1vZHVsZSBmcm9tIGNhY2hlXHJcbiBcdFx0XHRkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFxyXG4gXHRcdFx0Ly8gd2hlbiBkaXNwb3NpbmcgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGRpc3Bvc2UgaGFuZGxlclxyXG4gXHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcclxuIFx0XHJcbiBcdFx0XHQvLyByZW1vdmUgXCJwYXJlbnRzXCIgcmVmZXJlbmNlcyBmcm9tIGFsbCBjaGlsZHJlblxyXG4gXHRcdFx0Zm9yKGogPSAwOyBqIDwgbW9kdWxlLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiBcdFx0XHRcdHZhciBjaGlsZCA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlLmNoaWxkcmVuW2pdXTtcclxuIFx0XHRcdFx0aWYoIWNoaWxkKSBjb250aW51ZTtcclxuIFx0XHRcdFx0aWR4ID0gY2hpbGQucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aWYoaWR4ID49IDApIHtcclxuIFx0XHRcdFx0XHRjaGlsZC5wYXJlbnRzLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxyXG4gXHRcdHZhciBkZXBlbmRlbmN5O1xyXG4gXHRcdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcztcclxuIFx0XHRmb3IobW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRpZihtb2R1bGUpIHtcclxuIFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9IG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0XHRmb3IoaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xyXG4gXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xyXG4gXHRcdFx0XHRcdFx0aWR4ID0gbW9kdWxlLmNoaWxkcmVuLmluZGV4T2YoZGVwZW5kZW5jeSk7XHJcbiBcdFx0XHRcdFx0XHRpZihpZHggPj0gMCkgbW9kdWxlLmNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gTm90IGluIFwiYXBwbHlcIiBwaGFzZVxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImFwcGx5XCIpO1xyXG4gXHRcclxuIFx0XHRob3RDdXJyZW50SGFzaCA9IGhvdFVwZGF0ZU5ld0hhc2g7XHJcbiBcdFxyXG4gXHRcdC8vIGluc2VydCBuZXcgY29kZVxyXG4gXHRcdGZvcihtb2R1bGVJZCBpbiBhcHBsaWVkVXBkYXRlKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXBwbGllZFVwZGF0ZSwgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVttb2R1bGVJZF07XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xyXG4gXHRcdHZhciBlcnJvciA9IG51bGw7XHJcbiBcdFx0Zm9yKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0aWYobW9kdWxlKSB7XHJcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xyXG4gXHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV07XHJcbiBcdFx0XHRcdFx0XHRjYiA9IG1vZHVsZS5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcGVuZGVuY3ldO1xyXG4gXHRcdFx0XHRcdFx0aWYoY2IpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYoY2FsbGJhY2tzLmluZGV4T2YoY2IpID49IDApIGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdFx0XHRjYWxsYmFja3MucHVzaChjYik7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHRcdFx0Y2IgPSBjYWxsYmFja3NbaV07XHJcbiBcdFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0XHRjYihtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyk7XHJcbiBcdFx0XHRcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcclxuIFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV0sXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXHJcbiBcdFx0XHRcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yID0gZXJyO1xyXG4gXHRcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBMb2FkIHNlbGYgYWNjZXB0ZWQgbW9kdWxlc1xyXG4gXHRcdGZvcihpID0gMDsgaSA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0dmFyIGl0ZW0gPSBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXNbaV07XHJcbiBcdFx0XHRtb2R1bGVJZCA9IGl0ZW0ubW9kdWxlO1xyXG4gXHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xyXG4gXHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCk7XHJcbiBcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgaXRlbS5lcnJvckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gXHRcdFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdFx0XHRpdGVtLmVycm9ySGFuZGxlcihlcnIpO1xyXG4gXHRcdFx0XHRcdH0gY2F0Y2goZXJyMikge1xyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xyXG4gXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3ItaGFuZGxlci1lcnJvcmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxyXG4gXHRcdFx0XHRcdFx0XHRcdG9yZ2luYWxFcnJvcjogZXJyLCAvLyBUT0RPIHJlbW92ZSBpbiB3ZWJwYWNrIDRcclxuIFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbEVycm9yOiBlcnJcclxuIFx0XHRcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XHJcbiBcdFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjI7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHRpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0XHRcdGVycm9yID0gZXJyO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xyXG4gXHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXHJcbiBcdFx0XHRcdFx0XHR9KTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIGhhbmRsZSBlcnJvcnMgaW4gYWNjZXB0IGhhbmRsZXJzIGFuZCBzZWxmIGFjY2VwdGVkIG1vZHVsZSBsb2FkXHJcbiBcdFx0aWYoZXJyb3IpIHtcclxuIFx0XHRcdGhvdFNldFN0YXR1cyhcImZhaWxcIik7XHJcbiBcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcclxuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xyXG4gXHRcdFx0cmVzb2x2ZShvdXRkYXRlZE1vZHVsZXMpO1xyXG4gXHRcdH0pO1xyXG4gXHR9XHJcblxuIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aG90OiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpLFxuIFx0XHRcdHBhcmVudHM6IChob3RDdXJyZW50UGFyZW50c1RlbXAgPSBob3RDdXJyZW50UGFyZW50cywgaG90Q3VycmVudFBhcmVudHMgPSBbXSwgaG90Q3VycmVudFBhcmVudHNUZW1wKSxcbiBcdFx0XHRjaGlsZHJlbjogW11cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgaG90Q3JlYXRlUmVxdWlyZShtb2R1bGVJZCkpO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBfX3dlYnBhY2tfaGFzaF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhvdEN1cnJlbnRIYXNoOyB9O1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBob3RDcmVhdGVSZXF1aXJlKFwiLi9zcmMvbWFpbi5qc1wiKShfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL21haW4uanNcIik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNTIxN2E1YTEwM2NkNjliMzBkYTkiLCI8c3R5bGU+XG5odG1sLCBib2R5IHtcbsKgwqDCoMKgd2lkdGg6IDEwMCU7XG7CoMKgwqDCoGhlaWdodDogMTAwJTtcbn1cbi5hcHAge1xuwqDCoMKgwqBoZWlnaHQ6IDEwMCU7XG7CoMKgwqDCoHdpZHRoOiAxMDAlO1xufVxuPC9zdHlsZT5cbjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiYXBwXCI+XG4gICAgICAgIDxyb3V0ZXItdmlldz5cblxuICAgICAgICA8L3JvdXRlci12aWV3PlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBcbn1cbjwvc2NyaXB0PlxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYXBwLnZ1ZSIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5odG1sLCBib2R5IHtcXG7CoMKgwqDCoHdpZHRoOiAxMDAlO1xcbsKgwqDCoMKgaGVpZ2h0OiAxMDAlO1xcbn1cXG4uYXBwIHtcXG7CoMKgwqDCoGhlaWdodDogMTAwJTtcXG7CoMKgwqDCoHdpZHRoOiAxMDAlO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2hvbWUvd2poL+ahjOmdoi92dWVEZW1vL3NyYy9zcmMvYXBwLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBQ0E7QUFDQSxnQkFBQTtBQUNBLGlCQUFBO0NBQ0E7QUFDQTtBQUNBLGlCQUFBO0FBQ0EsZ0JBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiYXBwLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8c3R5bGU+XFxuaHRtbCwgYm9keSB7XFxuwqDCoMKgwqB3aWR0aDogMTAwJTtcXG7CoMKgwqDCoGhlaWdodDogMTAwJTtcXG59XFxuLmFwcCB7XFxuwqDCoMKgwqBoZWlnaHQ6IDEwMCU7XFxuwqDCoMKgwqB3aWR0aDogMTAwJTtcXG59XFxuPC9zdHlsZT5cXG48dGVtcGxhdGU+XFxuICAgIDxkaXYgY2xhc3M9XFxcImFwcFxcXCI+XFxuICAgICAgICA8cm91dGVyLXZpZXc+XFxuXFxuICAgICAgICA8L3JvdXRlci12aWV3PlxcbiAgICA8L2Rpdj5cXG48L3RlbXBsYXRlPlxcblxcbjxzY3JpcHQ+XFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBcXG59XFxuPC9zY3JpcHQ+XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTVlZjQ4OTU4XCIsXCJzY29wZWRcIjpmYWxzZSxcInNvdXJjZU1hcFwiOnRydWV9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvYXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtNWVmNDg5NThcIixcInNjb3BlZFwiOmZhbHNlLFwic291cmNlTWFwXCI6dHJ1ZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NyYy9hcHAudnVlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWlkYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsInZhciBWdWUgLy8gbGF0ZSBiaW5kXG52YXIgdmVyc2lvblxudmFyIG1hcCA9ICh3aW5kb3cuX19WVUVfSE9UX01BUF9fID0gT2JqZWN0LmNyZWF0ZShudWxsKSlcbnZhciBpbnN0YWxsZWQgPSBmYWxzZVxudmFyIGlzQnJvd3NlcmlmeSA9IGZhbHNlXG52YXIgaW5pdEhvb2tOYW1lID0gJ2JlZm9yZUNyZWF0ZSdcblxuZXhwb3J0cy5pbnN0YWxsID0gZnVuY3Rpb24gKHZ1ZSwgYnJvd3NlcmlmeSkge1xuICBpZiAoaW5zdGFsbGVkKSB7IHJldHVybiB9XG4gIGluc3RhbGxlZCA9IHRydWVcblxuICBWdWUgPSB2dWUuX19lc01vZHVsZSA/IHZ1ZS5kZWZhdWx0IDogdnVlXG4gIHZlcnNpb24gPSBWdWUudmVyc2lvbi5zcGxpdCgnLicpLm1hcChOdW1iZXIpXG4gIGlzQnJvd3NlcmlmeSA9IGJyb3dzZXJpZnlcblxuICAvLyBjb21wYXQgd2l0aCA8IDIuMC4wLWFscGhhLjdcbiAgaWYgKFZ1ZS5jb25maWcuX2xpZmVjeWNsZUhvb2tzLmluZGV4T2YoJ2luaXQnKSA+IC0xKSB7XG4gICAgaW5pdEhvb2tOYW1lID0gJ2luaXQnXG4gIH1cblxuICBleHBvcnRzLmNvbXBhdGlibGUgPSB2ZXJzaW9uWzBdID49IDJcbiAgaWYgKCFleHBvcnRzLmNvbXBhdGlibGUpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnW0hNUl0gWW91IGFyZSB1c2luZyBhIHZlcnNpb24gb2YgdnVlLWhvdC1yZWxvYWQtYXBpIHRoYXQgaXMgJyArXG4gICAgICAgICdvbmx5IGNvbXBhdGlibGUgd2l0aCBWdWUuanMgY29yZSBeMi4wLjAuJ1xuICAgIClcbiAgICByZXR1cm5cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlY29yZCBmb3IgYSBob3QgbW9kdWxlLCB3aGljaCBrZWVwcyB0cmFjayBvZiBpdHMgY29uc3RydWN0b3JcbiAqIGFuZCBpbnN0YW5jZXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZXhwb3J0cy5jcmVhdGVSZWNvcmQgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcbiAgaWYobWFwW2lkXSkgeyByZXR1cm4gfVxuICBcbiAgdmFyIEN0b3IgPSBudWxsXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIEN0b3IgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9uc1xuICB9XG4gIG1ha2VPcHRpb25zSG90KGlkLCBvcHRpb25zKVxuICBtYXBbaWRdID0ge1xuICAgIEN0b3I6IEN0b3IsXG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICBpbnN0YW5jZXM6IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBtb2R1bGUgaXMgcmVjb3JkZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqL1xuXG5leHBvcnRzLmlzUmVjb3JkZWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXBbaWRdICE9PSAndW5kZWZpbmVkJ1xufVxuXG4vKipcbiAqIE1ha2UgYSBDb21wb25lbnQgb3B0aW9ucyBvYmplY3QgaG90LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBtYWtlT3B0aW9uc0hvdChpZCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgdmFyIHJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiAoaCwgY3R4KSB7XG4gICAgICB2YXIgaW5zdGFuY2VzID0gbWFwW2lkXS5pbnN0YW5jZXNcbiAgICAgIGlmIChjdHggJiYgaW5zdGFuY2VzLmluZGV4T2YoY3R4LnBhcmVudCkgPCAwKSB7XG4gICAgICAgIGluc3RhbmNlcy5wdXNoKGN0eC5wYXJlbnQpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVuZGVyKGgsIGN0eClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW5qZWN0SG9vayhvcHRpb25zLCBpbml0SG9va05hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlY29yZCA9IG1hcFtpZF1cbiAgICAgIGlmICghcmVjb3JkLkN0b3IpIHtcbiAgICAgICAgcmVjb3JkLkN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yXG4gICAgICB9XG4gICAgICByZWNvcmQuaW5zdGFuY2VzLnB1c2godGhpcylcbiAgICB9KVxuICAgIGluamVjdEhvb2sob3B0aW9ucywgJ2JlZm9yZURlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbnN0YW5jZXMgPSBtYXBbaWRdLmluc3RhbmNlc1xuICAgICAgaW5zdGFuY2VzLnNwbGljZShpbnN0YW5jZXMuaW5kZXhPZih0aGlzKSwgMSlcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogSW5qZWN0IGEgaG9vayB0byBhIGhvdCByZWxvYWRhYmxlIGNvbXBvbmVudCBzbyB0aGF0XG4gKiB3ZSBjYW4ga2VlcCB0cmFjayBvZiBpdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhvb2tcbiAqL1xuXG5mdW5jdGlvbiBpbmplY3RIb29rKG9wdGlvbnMsIG5hbWUsIGhvb2spIHtcbiAgdmFyIGV4aXN0aW5nID0gb3B0aW9uc1tuYW1lXVxuICBvcHRpb25zW25hbWVdID0gZXhpc3RpbmdcbiAgICA/IEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpID8gZXhpc3RpbmcuY29uY2F0KGhvb2spIDogW2V4aXN0aW5nLCBob29rXVxuICAgIDogW2hvb2tdXG59XG5cbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKGlkLCBhcmcpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIFZ1ZSBjb21wb25lbnQgaG90LXJlbG9hZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuJ1xuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zIChvbGRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvbGRPcHRpb25zKSB7XG4gICAgaWYgKCEoa2V5IGluIG5ld09wdGlvbnMpKSB7XG4gICAgICBkZWxldGUgb2xkT3B0aW9uc1trZXldXG4gICAgfVxuICB9XG4gIGZvciAodmFyIGtleSQxIGluIG5ld09wdGlvbnMpIHtcbiAgICBvbGRPcHRpb25zW2tleSQxXSA9IG5ld09wdGlvbnNba2V5JDFdXG4gIH1cbn1cblxuZXhwb3J0cy5yZXJlbmRlciA9IHRyeVdyYXAoZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gIHZhciByZWNvcmQgPSBtYXBbaWRdXG4gIGlmICghb3B0aW9ucykge1xuICAgIHJlY29yZC5pbnN0YW5jZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UuJGZvcmNlVXBkYXRlKClcbiAgICB9KVxuICAgIHJldHVyblxuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zLm9wdGlvbnNcbiAgfVxuICBpZiAocmVjb3JkLkN0b3IpIHtcbiAgICByZWNvcmQuQ3Rvci5vcHRpb25zLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgcmVjb3JkLkN0b3Iub3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZuc1xuICAgIHJlY29yZC5pbnN0YW5jZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UuJG9wdGlvbnMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICAgIGluc3RhbmNlLiRvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zXG4gICAgICAvLyByZXNldCBzdGF0aWMgdHJlZXNcbiAgICAgIC8vIHByZSAyLjUsIGFsbCBzdGF0aWMgdHJlZXMgYXJlIGNhaGNlZCB0b2dldGhlciBvbiB0aGUgaW5zdGFuY2VcbiAgICAgIGlmIChpbnN0YW5jZS5fc3RhdGljVHJlZXMpIHtcbiAgICAgICAgaW5zdGFuY2UuX3N0YXRpY1RyZWVzID0gW11cbiAgICAgIH1cbiAgICAgIC8vIDIuNS4wXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWNvcmQuQ3Rvci5vcHRpb25zLmNhY2hlZCkpIHtcbiAgICAgICAgcmVjb3JkLkN0b3Iub3B0aW9ucy5jYWNoZWQgPSBbXVxuICAgICAgfVxuICAgICAgLy8gMi41LjNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGluc3RhbmNlLiRvcHRpb25zLmNhY2hlZCkpIHtcbiAgICAgICAgaW5zdGFuY2UuJG9wdGlvbnMuY2FjaGVkID0gW11cbiAgICAgIH1cbiAgICAgIC8vIHBvc3QgMi41LjQ6IHYtb25jZSB0cmVlcyBhcmUgY2FjaGVkIG9uIGluc3RhbmNlLl9zdGF0aWNUcmVlcy5cbiAgICAgIC8vIFB1cmUgc3RhdGljIHRyZWVzIGFyZSBjYWNoZWQgb24gdGhlIHN0YXRpY1JlbmRlckZucyBhcnJheVxuICAgICAgLy8gKGJvdGggYWxyZWFkeSByZXNldCBhYm92ZSlcbiAgICAgIGluc3RhbmNlLiRmb3JjZVVwZGF0ZSgpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBmdW5jdGlvbmFsIG9yIG5vIGluc3RhbmNlIGNyZWF0ZWQgeWV0XG4gICAgcmVjb3JkLm9wdGlvbnMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICByZWNvcmQub3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZuc1xuXG4gICAgLy8gaGFuZGxlIGZ1bmN0aW9uYWwgY29tcG9uZW50IHJlLXJlbmRlclxuICAgIGlmIChyZWNvcmQub3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyByZXJlbmRlciB3aXRoIGZ1bGwgb3B0aW9uc1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdXBkYXRlT3B0aW9ucyhyZWNvcmQub3B0aW9ucywgb3B0aW9ucylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRlbXBsYXRlLW9ubHkgcmVyZW5kZXIuXG4gICAgICAgIC8vIG5lZWQgdG8gaW5qZWN0IHRoZSBzdHlsZSBpbmplY3Rpb24gY29kZSBmb3IgQ1NTIG1vZHVsZXNcbiAgICAgICAgLy8gdG8gd29yayBwcm9wZXJseS5cbiAgICAgICAgdmFyIGluamVjdFN0eWxlcyA9IHJlY29yZC5vcHRpb25zLl9pbmplY3RTdHlsZXNcbiAgICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICAgIHZhciByZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgICAgIHJlY29yZC5vcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIChoLCBjdHgpIHtcbiAgICAgICAgICAgIGluamVjdFN0eWxlcy5jYWxsKGN0eClcbiAgICAgICAgICAgIHJldHVybiByZW5kZXIoaCwgY3R4KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjb3JkLm9wdGlvbnMuX0N0b3IgPSBudWxsXG4gICAgICAvLyAyLjUuM1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVjb3JkLm9wdGlvbnMuY2FjaGVkKSkge1xuICAgICAgICByZWNvcmQub3B0aW9ucy5jYWNoZWQgPSBbXVxuICAgICAgfVxuICAgICAgcmVjb3JkLmluc3RhbmNlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLiRmb3JjZVVwZGF0ZSgpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufSlcblxuZXhwb3J0cy5yZWxvYWQgPSB0cnlXcmFwKGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuICB2YXIgcmVjb3JkID0gbWFwW2lkXVxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMub3B0aW9uc1xuICAgIH1cbiAgICBtYWtlT3B0aW9uc0hvdChpZCwgb3B0aW9ucylcbiAgICBpZiAocmVjb3JkLkN0b3IpIHtcbiAgICAgIGlmICh2ZXJzaW9uWzFdIDwgMikge1xuICAgICAgICAvLyBwcmVzZXJ2ZSBwcmUgMi4yIGJlaGF2aW9yIGZvciBnbG9iYWwgbWl4aW4gaGFuZGxpbmdcbiAgICAgICAgcmVjb3JkLkN0b3IuZXh0ZW5kT3B0aW9ucyA9IG9wdGlvbnNcbiAgICAgIH1cbiAgICAgIHZhciBuZXdDdG9yID0gcmVjb3JkLkN0b3Iuc3VwZXIuZXh0ZW5kKG9wdGlvbnMpXG4gICAgICByZWNvcmQuQ3Rvci5vcHRpb25zID0gbmV3Q3Rvci5vcHRpb25zXG4gICAgICByZWNvcmQuQ3Rvci5jaWQgPSBuZXdDdG9yLmNpZFxuICAgICAgcmVjb3JkLkN0b3IucHJvdG90eXBlID0gbmV3Q3Rvci5wcm90b3R5cGVcbiAgICAgIGlmIChuZXdDdG9yLnJlbGVhc2UpIHtcbiAgICAgICAgLy8gdGVtcG9yYXJ5IGdsb2JhbCBtaXhpbiBzdHJhdGVneSB1c2VkIGluIDwgMi4wLjAtYWxwaGEuNlxuICAgICAgICBuZXdDdG9yLnJlbGVhc2UoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVPcHRpb25zKHJlY29yZC5vcHRpb25zLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuICByZWNvcmQuaW5zdGFuY2VzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoaW5zdGFuY2UuJHZub2RlICYmIGluc3RhbmNlLiR2bm9kZS5jb250ZXh0KSB7XG4gICAgICBpbnN0YW5jZS4kdm5vZGUuY29udGV4dC4kZm9yY2VVcGRhdGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLidcbiAgICAgIClcbiAgICB9XG4gIH0pXG59KVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaS9kaXN0L2luZGV4LmpzIiwiLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIElNUE9SVEFOVDogRG8gTk9UIHVzZSBFUzIwMTUgZmVhdHVyZXMgaW4gdGhpcyBmaWxlIChleGNlcHQgZm9yIG1vZHVsZXMpLlxuLy8gVGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICBzY3JpcHRFeHBvcnRzLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIsIC8qIHNlcnZlciBvbmx5ICovXG4gIHNoYWRvd01vZGUgLyogdnVlLWNsaSBvbmx5ICovXG4pIHtcbiAgc2NyaXB0RXhwb3J0cyA9IHNjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNjcmlwdEV4cG9ydHMgPSBzY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHsgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgdGhpcy4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290KSB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJhcHBcIiB9LCBbX2MoXCJyb3V0ZXItdmlld1wiKV0sIDEpXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi01ZWY0ODk1OFwiLCB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9KVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi01ZWY0ODk1OFwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9hcHAudnVlXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleC5qcz97XCJpZFwiOlwiZGF0YS12LTVlZjQ4OTU4XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2FwcC52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gICogdnVlLXJvdXRlciB2My4wLjFcbiAgKiAoYykgMjAxNyBFdmFuIFlvdVxuICAqIEBsaWNlbnNlIE1JVFxuICAqL1xuLyogICovXG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm4gKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZGl0aW9uKSB7XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFcnJvciAoZXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyKS5pbmRleE9mKCdFcnJvcicpID4gLTFcbn1cblxudmFyIFZpZXcgPSB7XG4gIG5hbWU6ICdyb3V0ZXItdmlldycsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoXywgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudDtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuXG4gICAgZGF0YS5yb3V0ZXJWaWV3ID0gdHJ1ZTtcblxuICAgIC8vIGRpcmVjdGx5IHVzZSBwYXJlbnQgY29udGV4dCdzIGNyZWF0ZUVsZW1lbnQoKSBmdW5jdGlvblxuICAgIC8vIHNvIHRoYXQgY29tcG9uZW50cyByZW5kZXJlZCBieSByb3V0ZXItdmlldyBjYW4gcmVzb2x2ZSBuYW1lZCBzbG90c1xuICAgIHZhciBoID0gcGFyZW50LiRjcmVhdGVFbGVtZW50O1xuICAgIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgICB2YXIgcm91dGUgPSBwYXJlbnQuJHJvdXRlO1xuICAgIHZhciBjYWNoZSA9IHBhcmVudC5fcm91dGVyVmlld0NhY2hlIHx8IChwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSA9IHt9KTtcblxuICAgIC8vIGRldGVybWluZSBjdXJyZW50IHZpZXcgZGVwdGgsIGFsc28gY2hlY2sgdG8gc2VlIGlmIHRoZSB0cmVlXG4gICAgLy8gaGFzIGJlZW4gdG9nZ2xlZCBpbmFjdGl2ZSBidXQga2VwdC1hbGl2ZS5cbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHZhciBpbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Ll9yb3V0ZXJSb290ICE9PSBwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuJHZub2RlICYmIHBhcmVudC4kdm5vZGUuZGF0YS5yb3V0ZXJWaWV3KSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Ll9pbmFjdGl2ZSkge1xuICAgICAgICBpbmFjdGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgZGF0YS5yb3V0ZXJWaWV3RGVwdGggPSBkZXB0aDtcblxuICAgIC8vIHJlbmRlciBwcmV2aW91cyB2aWV3IGlmIHRoZSB0cmVlIGlzIGluYWN0aXZlIGFuZCBrZXB0LWFsaXZlXG4gICAgaWYgKGluYWN0aXZlKSB7XG4gICAgICByZXR1cm4gaChjYWNoZVtuYW1lXSwgZGF0YSwgY2hpbGRyZW4pXG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZWQgPSByb3V0ZS5tYXRjaGVkW2RlcHRoXTtcbiAgICAvLyByZW5kZXIgZW1wdHkgbm9kZSBpZiBubyBtYXRjaGVkIHJvdXRlXG4gICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICBjYWNoZVtuYW1lXSA9IG51bGw7XG4gICAgICByZXR1cm4gaCgpXG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudCA9IGNhY2hlW25hbWVdID0gbWF0Y2hlZC5jb21wb25lbnRzW25hbWVdO1xuXG4gICAgLy8gYXR0YWNoIGluc3RhbmNlIHJlZ2lzdHJhdGlvbiBob29rXG4gICAgLy8gdGhpcyB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBpbmplY3RlZCBsaWZlY3ljbGUgaG9va3NcbiAgICBkYXRhLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgdmFsKSB7XG4gICAgICAvLyB2YWwgY291bGQgYmUgdW5kZWZpbmVkIGZvciB1bnJlZ2lzdHJhdGlvblxuICAgICAgdmFyIGN1cnJlbnQgPSBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgKHZhbCAmJiBjdXJyZW50ICE9PSB2bSkgfHxcbiAgICAgICAgKCF2YWwgJiYgY3VycmVudCA9PT0gdm0pXG4gICAgICApIHtcbiAgICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWxzbyByZWdpc3RlciBpbnN0YW5jZSBpbiBwcmVwYXRjaCBob29rXG4gICAgLy8gaW4gY2FzZSB0aGUgc2FtZSBjb21wb25lbnQgaW5zdGFuY2UgaXMgcmV1c2VkIGFjcm9zcyBkaWZmZXJlbnQgcm91dGVzXG4gICAgOyhkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KSkucHJlcGF0Y2ggPSBmdW5jdGlvbiAoXywgdm5vZGUpIHtcbiAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgfTtcblxuICAgIC8vIHJlc29sdmUgcHJvcHNcbiAgICB2YXIgcHJvcHNUb1Bhc3MgPSBkYXRhLnByb3BzID0gcmVzb2x2ZVByb3BzKHJvdXRlLCBtYXRjaGVkLnByb3BzICYmIG1hdGNoZWQucHJvcHNbbmFtZV0pO1xuICAgIGlmIChwcm9wc1RvUGFzcykge1xuICAgICAgLy8gY2xvbmUgdG8gcHJldmVudCBtdXRhdGlvblxuICAgICAgcHJvcHNUb1Bhc3MgPSBkYXRhLnByb3BzID0gZXh0ZW5kKHt9LCBwcm9wc1RvUGFzcyk7XG4gICAgICAvLyBwYXNzIG5vbi1kZWNsYXJlZCBwcm9wcyBhcyBhdHRyc1xuICAgICAgdmFyIGF0dHJzID0gZGF0YS5hdHRycyA9IGRhdGEuYXR0cnMgfHwge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHNUb1Bhc3MpIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnQucHJvcHMgfHwgIShrZXkgaW4gY29tcG9uZW50LnByb3BzKSkge1xuICAgICAgICAgIGF0dHJzW2tleV0gPSBwcm9wc1RvUGFzc1trZXldO1xuICAgICAgICAgIGRlbGV0ZSBwcm9wc1RvUGFzc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGgoY29tcG9uZW50LCBkYXRhLCBjaGlsZHJlbilcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVzb2x2ZVByb3BzIChyb3V0ZSwgY29uZmlnKSB7XG4gIHN3aXRjaCAodHlwZW9mIGNvbmZpZykge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiBjb25maWcocm91dGUpXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gY29uZmlnID8gcm91dGUucGFyYW1zIDogdW5kZWZpbmVkXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJwcm9wcyBpbiBcXFwiXCIgKyAocm91dGUucGF0aCkgKyBcIlxcXCIgaXMgYSBcIiArICh0eXBlb2YgY29uZmlnKSArIFwiLCBcIiArXG4gICAgICAgICAgXCJleHBlY3RpbmcgYW4gb2JqZWN0LCBmdW5jdGlvbiBvciBib29sZWFuLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0ZW5kICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qICAqL1xuXG52YXIgZW5jb2RlUmVzZXJ2ZVJFID0gL1shJygpKl0vZztcbnZhciBlbmNvZGVSZXNlcnZlUmVwbGFjZXIgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTsgfTtcbnZhciBjb21tYVJFID0gLyUyQy9nO1xuXG4vLyBmaXhlZCBlbmNvZGVVUklDb21wb25lbnQgd2hpY2ggaXMgbW9yZSBjb25mb3JtYW50IHRvIFJGQzM5ODY6XG4vLyAtIGVzY2FwZXMgWyEnKCkqXVxuLy8gLSBwcmVzZXJ2ZSBjb21tYXNcbnZhciBlbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKVxuICAucmVwbGFjZShlbmNvZGVSZXNlcnZlUkUsIGVuY29kZVJlc2VydmVSZXBsYWNlcilcbiAgLnJlcGxhY2UoY29tbWFSRSwgJywnKTsgfTtcblxudmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXJ5IChcbiAgcXVlcnksXG4gIGV4dHJhUXVlcnksXG4gIF9wYXJzZVF1ZXJ5XG4pIHtcbiAgaWYgKCBleHRyYVF1ZXJ5ID09PSB2b2lkIDAgKSBleHRyYVF1ZXJ5ID0ge307XG5cbiAgdmFyIHBhcnNlID0gX3BhcnNlUXVlcnkgfHwgcGFyc2VRdWVyeTtcbiAgdmFyIHBhcnNlZFF1ZXJ5O1xuICB0cnkge1xuICAgIHBhcnNlZFF1ZXJ5ID0gcGFyc2UocXVlcnkgfHwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBlLm1lc3NhZ2UpO1xuICAgIHBhcnNlZFF1ZXJ5ID0ge307XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIGV4dHJhUXVlcnkpIHtcbiAgICBwYXJzZWRRdWVyeVtrZXldID0gZXh0cmFRdWVyeVtrZXldO1xuICB9XG4gIHJldHVybiBwYXJzZWRRdWVyeVxufVxuXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5IChxdWVyeSkge1xuICB2YXIgcmVzID0ge307XG5cbiAgcXVlcnkgPSBxdWVyeS50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0cy5zaGlmdCgpKTtcbiAgICB2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMFxuICAgICAgPyBkZWNvZGUocGFydHMuam9pbignPScpKVxuICAgICAgOiBudWxsO1xuXG4gICAgaWYgKHJlc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc1trZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXNba2V5XSkpIHtcbiAgICAgIHJlc1trZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2tleV0gPSBbcmVzW2tleV0sIHZhbF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5IChvYmopIHtcbiAgdmFyIHJlcyA9IG9iaiA/IE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XG5cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoa2V5KVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XG4gICAgICAgIGlmICh2YWwyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsMiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwyKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcmJylcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsKVxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfSkuam9pbignJicpIDogbnVsbDtcbiAgcmV0dXJuIHJlcyA/IChcIj9cIiArIHJlcykgOiAnJ1xufVxuXG4vKiAgKi9cblxuXG52YXIgdHJhaWxpbmdTbGFzaFJFID0gL1xcLz8kLztcblxuZnVuY3Rpb24gY3JlYXRlUm91dGUgKFxuICByZWNvcmQsXG4gIGxvY2F0aW9uLFxuICByZWRpcmVjdGVkRnJvbSxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIHN0cmluZ2lmeVF1ZXJ5JCQxID0gcm91dGVyICYmIHJvdXRlci5vcHRpb25zLnN0cmluZ2lmeVF1ZXJ5O1xuXG4gIHZhciBxdWVyeSA9IGxvY2F0aW9uLnF1ZXJ5IHx8IHt9O1xuICB0cnkge1xuICAgIHF1ZXJ5ID0gY2xvbmUocXVlcnkpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByb3V0ZSA9IHtcbiAgICBuYW1lOiBsb2NhdGlvbi5uYW1lIHx8IChyZWNvcmQgJiYgcmVjb3JkLm5hbWUpLFxuICAgIG1ldGE6IChyZWNvcmQgJiYgcmVjb3JkLm1ldGEpIHx8IHt9LFxuICAgIHBhdGg6IGxvY2F0aW9uLnBhdGggfHwgJy8nLFxuICAgIGhhc2g6IGxvY2F0aW9uLmhhc2ggfHwgJycsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIHBhcmFtczogbG9jYXRpb24ucGFyYW1zIHx8IHt9LFxuICAgIGZ1bGxQYXRoOiBnZXRGdWxsUGF0aChsb2NhdGlvbiwgc3RyaW5naWZ5UXVlcnkkJDEpLFxuICAgIG1hdGNoZWQ6IHJlY29yZCA/IGZvcm1hdE1hdGNoKHJlY29yZCkgOiBbXVxuICB9O1xuICBpZiAocmVkaXJlY3RlZEZyb20pIHtcbiAgICByb3V0ZS5yZWRpcmVjdGVkRnJvbSA9IGdldEZ1bGxQYXRoKHJlZGlyZWN0ZWRGcm9tLCBzdHJpbmdpZnlRdWVyeSQkMSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUocm91dGUpXG59XG5cbmZ1bmN0aW9uIGNsb25lICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKGNsb25lKVxuICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICByZXNba2V5XSA9IGNsb25lKHZhbHVlW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbn1cblxuLy8gdGhlIHN0YXJ0aW5nIHJvdXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5pdGlhbCBzdGF0ZVxudmFyIFNUQVJUID0gY3JlYXRlUm91dGUobnVsbCwge1xuICBwYXRoOiAnLydcbn0pO1xuXG5mdW5jdGlvbiBmb3JtYXRNYXRjaCAocmVjb3JkKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgd2hpbGUgKHJlY29yZCkge1xuICAgIHJlcy51bnNoaWZ0KHJlY29yZCk7XG4gICAgcmVjb3JkID0gcmVjb3JkLnBhcmVudDtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldEZ1bGxQYXRoIChcbiAgcmVmLFxuICBfc3RyaW5naWZ5UXVlcnlcbikge1xuICB2YXIgcGF0aCA9IHJlZi5wYXRoO1xuICB2YXIgcXVlcnkgPSByZWYucXVlcnk7IGlmICggcXVlcnkgPT09IHZvaWQgMCApIHF1ZXJ5ID0ge307XG4gIHZhciBoYXNoID0gcmVmLmhhc2g7IGlmICggaGFzaCA9PT0gdm9pZCAwICkgaGFzaCA9ICcnO1xuXG4gIHZhciBzdHJpbmdpZnkgPSBfc3RyaW5naWZ5UXVlcnkgfHwgc3RyaW5naWZ5UXVlcnk7XG4gIHJldHVybiAocGF0aCB8fCAnLycpICsgc3RyaW5naWZ5KHF1ZXJ5KSArIGhhc2hcbn1cblxuZnVuY3Rpb24gaXNTYW1lUm91dGUgKGEsIGIpIHtcbiAgaWYgKGIgPT09IFNUQVJUKSB7XG4gICAgcmV0dXJuIGEgPT09IGJcbiAgfSBlbHNlIGlmICghYikge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKGEucGF0aCAmJiBiLnBhdGgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgPT09IGIucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpICYmXG4gICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnF1ZXJ5LCBiLnF1ZXJ5KVxuICAgIClcbiAgfSBlbHNlIGlmIChhLm5hbWUgJiYgYi5uYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEubmFtZSA9PT0gYi5uYW1lICYmXG4gICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnF1ZXJ5LCBiLnF1ZXJ5KSAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnBhcmFtcywgYi5wYXJhbXMpXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0RXF1YWwgKGEsIGIpIHtcbiAgaWYgKCBhID09PSB2b2lkIDAgKSBhID0ge307XG4gIGlmICggYiA9PT0gdm9pZCAwICkgYiA9IHt9O1xuXG4gIC8vIGhhbmRsZSBudWxsIHZhbHVlICMxNTY2XG4gIGlmICghYSB8fCAhYikgeyByZXR1cm4gYSA9PT0gYiB9XG4gIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIGFLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgYVZhbCA9IGFba2V5XTtcbiAgICB2YXIgYlZhbCA9IGJba2V5XTtcbiAgICAvLyBjaGVjayBuZXN0ZWQgZXF1YWxpdHlcbiAgICBpZiAodHlwZW9mIGFWYWwgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiVmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0RXF1YWwoYVZhbCwgYlZhbClcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhhVmFsKSA9PT0gU3RyaW5nKGJWYWwpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlzSW5jbHVkZWRSb3V0ZSAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiAoXG4gICAgY3VycmVudC5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnLycpLmluZGV4T2YoXG4gICAgICB0YXJnZXQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKVxuICAgICkgPT09IDAgJiZcbiAgICAoIXRhcmdldC5oYXNoIHx8IGN1cnJlbnQuaGFzaCA9PT0gdGFyZ2V0Lmhhc2gpICYmXG4gICAgcXVlcnlJbmNsdWRlcyhjdXJyZW50LnF1ZXJ5LCB0YXJnZXQucXVlcnkpXG4gIClcbn1cblxuZnVuY3Rpb24gcXVlcnlJbmNsdWRlcyAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICBpZiAoIShrZXkgaW4gY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKiAgKi9cblxuLy8gd29yayBhcm91bmQgd2VpcmQgZmxvdyBidWdcbnZhciB0b1R5cGVzID0gW1N0cmluZywgT2JqZWN0XTtcbnZhciBldmVudFR5cGVzID0gW1N0cmluZywgQXJyYXldO1xuXG52YXIgTGluayA9IHtcbiAgbmFtZTogJ3JvdXRlci1saW5rJyxcbiAgcHJvcHM6IHtcbiAgICB0bzoge1xuICAgICAgdHlwZTogdG9UeXBlcyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdhJ1xuICAgIH0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHR5cGU6IGV2ZW50VHlwZXMsXG4gICAgICBkZWZhdWx0OiAnY2xpY2snXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMuJHJvdXRlcjtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuJHJvdXRlO1xuICAgIHZhciByZWYgPSByb3V0ZXIucmVzb2x2ZSh0aGlzLnRvLCBjdXJyZW50LCB0aGlzLmFwcGVuZCk7XG4gICAgdmFyIGxvY2F0aW9uID0gcmVmLmxvY2F0aW9uO1xuICAgIHZhciByb3V0ZSA9IHJlZi5yb3V0ZTtcbiAgICB2YXIgaHJlZiA9IHJlZi5ocmVmO1xuXG4gICAgdmFyIGNsYXNzZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsQWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rRXhhY3RBY3RpdmVDbGFzcztcbiAgICAvLyBTdXBwb3J0IGdsb2JhbCBlbXB0eSBhY3RpdmUgY2xhc3NcbiAgICB2YXIgYWN0aXZlQ2xhc3NGYWxsYmFjayA9IGdsb2JhbEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gJ3JvdXRlci1saW5rLWFjdGl2ZSdcbiAgICAgICAgICAgIDogZ2xvYmFsQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayA9IGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyAncm91dGVyLWxpbmstZXhhY3QtYWN0aXZlJ1xuICAgICAgICAgICAgOiBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzO1xuICAgIHZhciBhY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyBhY3RpdmVDbGFzc0ZhbGxiYWNrXG4gICAgICAgICAgICA6IHRoaXMuYWN0aXZlQ2xhc3M7XG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3MgPSB0aGlzLmV4YWN0QWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyBleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2tcbiAgICAgICAgICAgIDogdGhpcy5leGFjdEFjdGl2ZUNsYXNzO1xuICAgIHZhciBjb21wYXJlVGFyZ2V0ID0gbG9jYXRpb24ucGF0aFxuICAgICAgPyBjcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbiwgbnVsbCwgcm91dGVyKVxuICAgICAgOiByb3V0ZTtcblxuICAgIGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc10gPSBpc1NhbWVSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0KTtcbiAgICBjbGFzc2VzW2FjdGl2ZUNsYXNzXSA9IHRoaXMuZXhhY3RcbiAgICAgID8gY2xhc3Nlc1tleGFjdEFjdGl2ZUNsYXNzXVxuICAgICAgOiBpc0luY2x1ZGVkUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldCk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZ3VhcmRFdmVudChlKSkge1xuICAgICAgICBpZiAodGhpcyQxLnJlcGxhY2UpIHtcbiAgICAgICAgICByb3V0ZXIucmVwbGFjZShsb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyLnB1c2gobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvbiA9IHsgY2xpY2s6IGd1YXJkRXZlbnQgfTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmV2ZW50KSkge1xuICAgICAgdGhpcy5ldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IG9uW2VdID0gaGFuZGxlcjsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uW3RoaXMuZXZlbnRdID0gaGFuZGxlcjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGNsYXNzOiBjbGFzc2VzXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnRhZyA9PT0gJ2EnKSB7XG4gICAgICBkYXRhLm9uID0gb247XG4gICAgICBkYXRhLmF0dHJzID0geyBocmVmOiBocmVmIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IDxhPiBjaGlsZCBhbmQgYXBwbHkgbGlzdGVuZXIgYW5kIGhyZWZcbiAgICAgIHZhciBhID0gZmluZEFuY2hvcih0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIDxhPiBpcyBhIHN0YXRpYyBub2RlXG4gICAgICAgIGEuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGV4dGVuZCA9IF9WdWUudXRpbC5leHRlbmQ7XG4gICAgICAgIHZhciBhRGF0YSA9IGEuZGF0YSA9IGV4dGVuZCh7fSwgYS5kYXRhKTtcbiAgICAgICAgYURhdGEub24gPSBvbjtcbiAgICAgICAgdmFyIGFBdHRycyA9IGEuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYS5kYXRhLmF0dHJzKTtcbiAgICAgICAgYUF0dHJzLmhyZWYgPSBocmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG9lc24ndCBoYXZlIDxhPiBjaGlsZCwgYXBwbHkgbGlzdGVuZXIgdG8gc2VsZlxuICAgICAgICBkYXRhLm9uID0gb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGhpcy50YWcsIGRhdGEsIHRoaXMuJHNsb3RzLmRlZmF1bHQpXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGd1YXJkRXZlbnQgKGUpIHtcbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2l0aCBjb250cm9sIGtleXNcbiAgaWYgKGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCB3aGVuIHByZXZlbnREZWZhdWx0IGNhbGxlZFxuICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IG9uIHJpZ2h0IGNsaWNrXG4gIGlmIChlLmJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9uICE9PSAwKSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IGlmIGB0YXJnZXQ9XCJfYmxhbmtcImBcbiAgaWYgKGUuY3VycmVudFRhcmdldCAmJiBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKSB7XG4gICAgdmFyIHRhcmdldCA9IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpO1xuICAgIGlmICgvXFxiX2JsYW5rXFxiL2kudGVzdCh0YXJnZXQpKSB7IHJldHVybiB9XG4gIH1cbiAgLy8gdGhpcyBtYXkgYmUgYSBXZWV4IGV2ZW50IHdoaWNoIGRvZXNuJ3QgaGF2ZSB0aGlzIG1ldGhvZFxuICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaW5kQW5jaG9yIChjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICB2YXIgY2hpbGQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICdhJykge1xuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbiAmJiAoY2hpbGQgPSBmaW5kQW5jaG9yKGNoaWxkLmNoaWxkcmVuKSkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBfVnVlO1xuXG5mdW5jdGlvbiBpbnN0YWxsIChWdWUpIHtcbiAgaWYgKGluc3RhbGwuaW5zdGFsbGVkICYmIF9WdWUgPT09IFZ1ZSkgeyByZXR1cm4gfVxuICBpbnN0YWxsLmluc3RhbGxlZCA9IHRydWU7XG5cbiAgX1Z1ZSA9IFZ1ZTtcblxuICB2YXIgaXNEZWYgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9O1xuXG4gIHZhciByZWdpc3Rlckluc3RhbmNlID0gZnVuY3Rpb24gKHZtLCBjYWxsVmFsKSB7XG4gICAgdmFyIGkgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gICAgaWYgKGlzRGVmKGkpICYmIGlzRGVmKGkgPSBpLmRhdGEpICYmIGlzRGVmKGkgPSBpLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSkpIHtcbiAgICAgIGkodm0sIGNhbGxWYWwpO1xuICAgIH1cbiAgfTtcblxuICBWdWUubWl4aW4oe1xuICAgIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlICgpIHtcbiAgICAgIGlmIChpc0RlZih0aGlzLiRvcHRpb25zLnJvdXRlcikpIHtcbiAgICAgICAgdGhpcy5fcm91dGVyUm9vdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3JvdXRlciA9IHRoaXMuJG9wdGlvbnMucm91dGVyO1xuICAgICAgICB0aGlzLl9yb3V0ZXIuaW5pdCh0aGlzKTtcbiAgICAgICAgVnVlLnV0aWwuZGVmaW5lUmVhY3RpdmUodGhpcywgJ19yb3V0ZScsIHRoaXMuX3JvdXRlci5oaXN0b3J5LmN1cnJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcm91dGVyUm9vdCA9ICh0aGlzLiRwYXJlbnQgJiYgdGhpcy4kcGFyZW50Ll9yb3V0ZXJSb290KSB8fCB0aGlzO1xuICAgICAgfVxuICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCB0aGlzKTtcbiAgICB9LFxuICAgIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcyk7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyUm9vdC5fcm91dGVyIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyUm9vdC5fcm91dGUgfVxuICB9KTtcblxuICBWdWUuY29tcG9uZW50KCdyb3V0ZXItdmlldycsIFZpZXcpO1xuICBWdWUuY29tcG9uZW50KCdyb3V0ZXItbGluaycsIExpbmspO1xuXG4gIHZhciBzdHJhdHMgPSBWdWUuY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcbiAgLy8gdXNlIHRoZSBzYW1lIGhvb2sgbWVyZ2luZyBzdHJhdGVneSBmb3Igcm91dGUgaG9va3NcbiAgc3RyYXRzLmJlZm9yZVJvdXRlRW50ZXIgPSBzdHJhdHMuYmVmb3JlUm91dGVMZWF2ZSA9IHN0cmF0cy5iZWZvcmVSb3V0ZVVwZGF0ZSA9IHN0cmF0cy5jcmVhdGVkO1xufVxuXG4vKiAgKi9cblxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGggKFxuICByZWxhdGl2ZSxcbiAgYmFzZSxcbiAgYXBwZW5kXG4pIHtcbiAgdmFyIGZpcnN0Q2hhciA9IHJlbGF0aXZlLmNoYXJBdCgwKTtcbiAgaWYgKGZpcnN0Q2hhciA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlXG4gIH1cblxuICBpZiAoZmlyc3RDaGFyID09PSAnPycgfHwgZmlyc3RDaGFyID09PSAnIycpIHtcbiAgICByZXR1cm4gYmFzZSArIHJlbGF0aXZlXG4gIH1cblxuICB2YXIgc3RhY2sgPSBiYXNlLnNwbGl0KCcvJyk7XG5cbiAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNlZ21lbnQgaWY6XG4gIC8vIC0gbm90IGFwcGVuZGluZ1xuICAvLyAtIGFwcGVuZGluZyB0byB0cmFpbGluZyBzbGFzaCAobGFzdCBzZWdtZW50IGlzIGVtcHR5KVxuICBpZiAoIWFwcGVuZCB8fCAhc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIC8vIHJlc29sdmUgcmVsYXRpdmUgcGF0aFxuICB2YXIgc2VnbWVudHMgPSByZWxhdGl2ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09ICcuJykge1xuICAgICAgc3RhY2sucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBlbnN1cmUgbGVhZGluZyBzbGFzaFxuICBpZiAoc3RhY2tbMF0gIT09ICcnKSB7XG4gICAgc3RhY2sudW5zaGlmdCgnJyk7XG4gIH1cblxuICByZXR1cm4gc3RhY2suam9pbignLycpXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICB2YXIgaGFzaCA9ICcnO1xuICB2YXIgcXVlcnkgPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgIGhhc2ggPSBwYXRoLnNsaWNlKGhhc2hJbmRleCk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxdWVyeUluZGV4ID49IDApIHtcbiAgICBxdWVyeSA9IHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEpO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHF1ZXJ5SW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBoYXNoOiBoYXNoXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5QYXRoIChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcL1xcLy9nLCAnLycpXG59XG5cbnZhciBpc2FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbnZhciBwYXRoVG9SZWdleHBfMSA9IHBhdGhUb1JlZ2V4cDtcbnZhciBwYXJzZV8xID0gcGFyc2U7XG52YXIgY29tcGlsZV8xID0gY29tcGlsZTtcbnZhciB0b2tlbnNUb0Z1bmN0aW9uXzEgPSB0b2tlbnNUb0Z1bmN0aW9uO1xudmFyIHRva2Vuc1RvUmVnRXhwXzEgPSB0b2tlbnNUb1JlZ0V4cDtcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYXBwZWFyIGluIGZ1dHVyZSBtYXRjaGVzLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiLCB1bmRlZmluZWRdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxuICAnKFtcXFxcLy5dKT8oPzooPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpKFsrKj9dKT98KFxcXFwqKSknXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIga2V5ID0gMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHBhdGggPSAnJztcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJztcbiAgdmFyIHJlcztcblxuICB3aGlsZSAoKHJlcyA9IFBBVEhfUkVHRVhQLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIHZhciBtID0gcmVzWzBdO1xuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdO1xuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXg7XG4gICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldCk7XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aDtcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV07XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0ID0gc3RyW2luZGV4XTtcbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdO1xuICAgIHZhciBuYW1lID0gcmVzWzNdO1xuICAgIHZhciBjYXB0dXJlID0gcmVzWzRdO1xuICAgIHZhciBncm91cCA9IHJlc1s1XTtcbiAgICB2YXIgbW9kaWZpZXIgPSByZXNbNl07XG4gICAgdmFyIGFzdGVyaXNrID0gcmVzWzddO1xuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gICAgICBwYXRoID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWwgPSBwcmVmaXggIT0gbnVsbCAmJiBuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gcHJlZml4O1xuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonO1xuICAgIHZhciBkZWxpbWl0ZXIgPSByZXNbMl0gfHwgZGVmYXVsdERlbGltaXRlcjtcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXA7XG5cbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgcGFydGlhbDogcGFydGlhbCxcbiAgICAgIGFzdGVyaXNrOiAhIWFzdGVyaXNrLFxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTWF0Y2ggYW55IGNoYXJhY3RlcnMgc3RpbGwgcmVtYWluaW5nLlxuICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KTtcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshZnVuY3Rpb24oT2JqZWN0PSwgT2JqZWN0PSl9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpKVxufVxuXG4vKipcbiAqIFByZXR0aWVyIGVuY29kaW5nIG9mIFVSSSBwYXRoIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1tcXC8/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRW5jb2RlIHRoZSBhc3RlcmlzayBwYXJhbWV0ZXIuIFNpbWlsYXIgdG8gYHByZXR0eWAsIGJ1dCBhbGxvd3Mgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUFzdGVyaXNrIChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24gKHRva2Vucykge1xuICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aCk7XG5cbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnO1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9O1xuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuO1xuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV07XG4gICAgICB2YXIgc2VnbWVudDtcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSk7XG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKTtcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5cztcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSdcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpO1xuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSk7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpO1xuXG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICAgICAgICAgIHRva2Vuc1xuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlO1xuICB2YXIgcm91dGUgPSAnJztcblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeCk7XG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJztcblxuICAgICAga2V5cy5wdXNoKHRva2VuKTtcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKic7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICBjYXB0dXJlID0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJztcbiAgICAgIH1cblxuICAgICAgcm91dGUgKz0gY2FwdHVyZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJyk7XG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyO1xuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhIHNsYXNoIGF0IHRoZSBlbmQgb2YgbWF0Y2guIElmIHRoZSBwYXRoIHRvXG4gIC8vIG1hdGNoIGFscmVhZHkgZW5kcyB3aXRoIGEgc2xhc2gsIHdlIHJlbW92ZSBpdCBmb3IgY29uc2lzdGVuY3kuIFRoZSBzbGFzaFxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gIC8vIGluIG5vbi1lbmRpbmcgbW9kZSwgd2hlcmUgXCIvdGVzdC9cIiBzaG91bGRuJ3QgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nO1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJztcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknO1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKlxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19ICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpO1xuICAgIGtleXMgPSBbXTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cykpXG4gIH1cblxuICBpZiAoaXNhcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbn1cblxucGF0aFRvUmVnZXhwXzEucGFyc2UgPSBwYXJzZV8xO1xucGF0aFRvUmVnZXhwXzEuY29tcGlsZSA9IGNvbXBpbGVfMTtcbnBhdGhUb1JlZ2V4cF8xLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXzE7XG5wYXRoVG9SZWdleHBfMS50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXzE7XG5cbi8qICAqL1xuXG4vLyAkZmxvdy1kaXNhYmxlLWxpbmVcbnZhciByZWdleHBDb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBmaWxsUGFyYW1zIChcbiAgcGF0aCxcbiAgcGFyYW1zLFxuICByb3V0ZU1zZ1xuKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZpbGxlciA9XG4gICAgICByZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gfHxcbiAgICAgIChyZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gPSBwYXRoVG9SZWdleHBfMS5jb21waWxlKHBhdGgpKTtcbiAgICByZXR1cm4gZmlsbGVyKHBhcmFtcyB8fCB7fSwgeyBwcmV0dHk6IHRydWUgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCAoXCJtaXNzaW5nIHBhcmFtIGZvciBcIiArIHJvdXRlTXNnICsgXCI6IFwiICsgKGUubWVzc2FnZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlTWFwIChcbiAgcm91dGVzLFxuICBvbGRQYXRoTGlzdCxcbiAgb2xkUGF0aE1hcCxcbiAgb2xkTmFtZU1hcFxuKSB7XG4gIC8vIHRoZSBwYXRoIGxpc3QgaXMgdXNlZCB0byBjb250cm9sIHBhdGggbWF0Y2hpbmcgcHJpb3JpdHlcbiAgdmFyIHBhdGhMaXN0ID0gb2xkUGF0aExpc3QgfHwgW107XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgcGF0aE1hcCA9IG9sZFBhdGhNYXAgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciBuYW1lTWFwID0gb2xkTmFtZU1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwLCByb3V0ZSk7XG4gIH0pO1xuXG4gIC8vIGVuc3VyZSB3aWxkY2FyZCByb3V0ZXMgYXJlIGFsd2F5cyBhdCB0aGUgZW5kXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aExpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHBhdGhMaXN0W2ldID09PSAnKicpIHtcbiAgICAgIHBhdGhMaXN0LnB1c2gocGF0aExpc3Quc3BsaWNlKGksIDEpWzBdKTtcbiAgICAgIGwtLTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhMaXN0OiBwYXRoTGlzdCxcbiAgICBwYXRoTWFwOiBwYXRoTWFwLFxuICAgIG5hbWVNYXA6IG5hbWVNYXBcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSb3V0ZVJlY29yZCAoXG4gIHBhdGhMaXN0LFxuICBwYXRoTWFwLFxuICBuYW1lTWFwLFxuICByb3V0ZSxcbiAgcGFyZW50LFxuICBtYXRjaEFzXG4pIHtcbiAgdmFyIHBhdGggPSByb3V0ZS5wYXRoO1xuICB2YXIgbmFtZSA9IHJvdXRlLm5hbWU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHBhdGggIT0gbnVsbCwgXCJcXFwicGF0aFxcXCIgaXMgcmVxdWlyZWQgaW4gYSByb3V0ZSBjb25maWd1cmF0aW9uLlwiKTtcbiAgICBhc3NlcnQoXG4gICAgICB0eXBlb2Ygcm91dGUuY29tcG9uZW50ICE9PSAnc3RyaW5nJyxcbiAgICAgIFwicm91dGUgY29uZmlnIFxcXCJjb21wb25lbnRcXFwiIGZvciBwYXRoOiBcIiArIChTdHJpbmcocGF0aCB8fCBuYW1lKSkgKyBcIiBjYW5ub3QgYmUgYSBcIiArXG4gICAgICBcInN0cmluZyBpZC4gVXNlIGFuIGFjdHVhbCBjb21wb25lbnQgaW5zdGVhZC5cIlxuICAgICk7XG4gIH1cblxuICB2YXIgcGF0aFRvUmVnZXhwT3B0aW9ucyA9IHJvdXRlLnBhdGhUb1JlZ2V4cE9wdGlvbnMgfHwge307XG4gIHZhciBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgoXG4gICAgcGF0aCxcbiAgICBwYXJlbnQsXG4gICAgcGF0aFRvUmVnZXhwT3B0aW9ucy5zdHJpY3RcbiAgKTtcblxuICBpZiAodHlwZW9mIHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09ICdib29sZWFuJykge1xuICAgIHBhdGhUb1JlZ2V4cE9wdGlvbnMuc2Vuc2l0aXZlID0gcm91dGUuY2FzZVNlbnNpdGl2ZTtcbiAgfVxuXG4gIHZhciByZWNvcmQgPSB7XG4gICAgcGF0aDogbm9ybWFsaXplZFBhdGgsXG4gICAgcmVnZXg6IGNvbXBpbGVSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRQYXRoLCBwYXRoVG9SZWdleHBPcHRpb25zKSxcbiAgICBjb21wb25lbnRzOiByb3V0ZS5jb21wb25lbnRzIHx8IHsgZGVmYXVsdDogcm91dGUuY29tcG9uZW50IH0sXG4gICAgaW5zdGFuY2VzOiB7fSxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIG1hdGNoQXM6IG1hdGNoQXMsXG4gICAgcmVkaXJlY3Q6IHJvdXRlLnJlZGlyZWN0LFxuICAgIGJlZm9yZUVudGVyOiByb3V0ZS5iZWZvcmVFbnRlcixcbiAgICBtZXRhOiByb3V0ZS5tZXRhIHx8IHt9LFxuICAgIHByb3BzOiByb3V0ZS5wcm9wcyA9PSBudWxsXG4gICAgICA/IHt9XG4gICAgICA6IHJvdXRlLmNvbXBvbmVudHNcbiAgICAgICAgPyByb3V0ZS5wcm9wc1xuICAgICAgICA6IHsgZGVmYXVsdDogcm91dGUucHJvcHMgfVxuICB9O1xuXG4gIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgIC8vIFdhcm4gaWYgcm91dGUgaXMgbmFtZWQsIGRvZXMgbm90IHJlZGlyZWN0IGFuZCBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLlxuICAgIC8vIElmIHVzZXJzIG5hdmlnYXRlIHRvIHRoaXMgcm91dGUgYnkgbmFtZSwgdGhlIGRlZmF1bHQgY2hpbGQgd2lsbFxuICAgIC8vIG5vdCBiZSByZW5kZXJlZCAoR0ggSXNzdWUgIzYyOSlcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHJvdXRlLm5hbWUgJiYgIXJvdXRlLnJlZGlyZWN0ICYmIHJvdXRlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAvXlxcLz8kLy50ZXN0KGNoaWxkLnBhdGgpOyB9KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiTmFtZWQgUm91dGUgJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuIFwiICtcbiAgICAgICAgICBcIldoZW4gbmF2aWdhdGluZyB0byB0aGlzIG5hbWVkIHJvdXRlICg6dG89XFxcIntuYW1lOiAnXCIgKyAocm91dGUubmFtZSkgKyBcIidcXFwiKSwgXCIgK1xuICAgICAgICAgIFwidGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgd2lsbCBub3QgYmUgcmVuZGVyZWQuIFJlbW92ZSB0aGUgbmFtZSBmcm9tIFwiICtcbiAgICAgICAgICBcInRoaXMgcm91dGUgYW5kIHVzZSB0aGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSBmb3IgbmFtZWQgXCIgK1xuICAgICAgICAgIFwibGlua3MgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGNoaWxkTWF0Y2hBcyA9IG1hdGNoQXNcbiAgICAgICAgPyBjbGVhblBhdGgoKG1hdGNoQXMgKyBcIi9cIiArIChjaGlsZC5wYXRoKSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIGNoaWxkLCByZWNvcmQsIGNoaWxkTWF0Y2hBcyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocm91dGUuYWxpYXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBhbGlhc2VzID0gQXJyYXkuaXNBcnJheShyb3V0ZS5hbGlhcylcbiAgICAgID8gcm91dGUuYWxpYXNcbiAgICAgIDogW3JvdXRlLmFsaWFzXTtcblxuICAgIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgIHZhciBhbGlhc1JvdXRlID0ge1xuICAgICAgICBwYXRoOiBhbGlhcyxcbiAgICAgICAgY2hpbGRyZW46IHJvdXRlLmNoaWxkcmVuXG4gICAgICB9O1xuICAgICAgYWRkUm91dGVSZWNvcmQoXG4gICAgICAgIHBhdGhMaXN0LFxuICAgICAgICBwYXRoTWFwLFxuICAgICAgICBuYW1lTWFwLFxuICAgICAgICBhbGlhc1JvdXRlLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIHJlY29yZC5wYXRoIHx8ICcvJyAvLyBtYXRjaEFzXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFwYXRoTWFwW3JlY29yZC5wYXRoXSkge1xuICAgIHBhdGhMaXN0LnB1c2gocmVjb3JkLnBhdGgpO1xuICAgIHBhdGhNYXBbcmVjb3JkLnBhdGhdID0gcmVjb3JkO1xuICB9XG5cbiAgaWYgKG5hbWUpIHtcbiAgICBpZiAoIW5hbWVNYXBbbmFtZV0pIHtcbiAgICAgIG5hbWVNYXBbbmFtZV0gPSByZWNvcmQ7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFtYXRjaEFzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJEdXBsaWNhdGUgbmFtZWQgcm91dGVzIGRlZmluaXRpb246IFwiICtcbiAgICAgICAgXCJ7IG5hbWU6IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIHBhdGg6IFxcXCJcIiArIChyZWNvcmQucGF0aCkgKyBcIlxcXCIgfVwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21waWxlUm91dGVSZWdleCAocGF0aCwgcGF0aFRvUmVnZXhwT3B0aW9ucykge1xuICB2YXIgcmVnZXggPSBwYXRoVG9SZWdleHBfMShwYXRoLCBbXSwgcGF0aFRvUmVnZXhwT3B0aW9ucyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJlZ2V4LmtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB3YXJuKCFrZXlzW2tleS5uYW1lXSwgKFwiRHVwbGljYXRlIHBhcmFtIGtleXMgaW4gcm91dGUgd2l0aCBwYXRoOiBcXFwiXCIgKyBwYXRoICsgXCJcXFwiXCIpKTtcbiAgICAgIGtleXNba2V5Lm5hbWVdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVnZXhcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUGF0aCAocGF0aCwgcGFyZW50LCBzdHJpY3QpIHtcbiAgaWYgKCFzdHJpY3QpIHsgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKTsgfVxuICBpZiAocGF0aFswXSA9PT0gJy8nKSB7IHJldHVybiBwYXRoIH1cbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7IHJldHVybiBwYXRoIH1cbiAgcmV0dXJuIGNsZWFuUGF0aCgoKHBhcmVudC5wYXRoKSArIFwiL1wiICsgcGF0aCkpXG59XG5cbi8qICAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICBhcHBlbmQsXG4gIHJvdXRlclxuKSB7XG4gIHZhciBuZXh0ID0gdHlwZW9mIHJhdyA9PT0gJ3N0cmluZycgPyB7IHBhdGg6IHJhdyB9IDogcmF3O1xuICAvLyBuYW1lZCB0YXJnZXRcbiAgaWYgKG5leHQubmFtZSB8fCBuZXh0Ll9ub3JtYWxpemVkKSB7XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIC8vIHJlbGF0aXZlIHBhcmFtc1xuICBpZiAoIW5leHQucGF0aCAmJiBuZXh0LnBhcmFtcyAmJiBjdXJyZW50KSB7XG4gICAgbmV4dCA9IGFzc2lnbih7fSwgbmV4dCk7XG4gICAgbmV4dC5fbm9ybWFsaXplZCA9IHRydWU7XG4gICAgdmFyIHBhcmFtcyA9IGFzc2lnbihhc3NpZ24oe30sIGN1cnJlbnQucGFyYW1zKSwgbmV4dC5wYXJhbXMpO1xuICAgIGlmIChjdXJyZW50Lm5hbWUpIHtcbiAgICAgIG5leHQubmFtZSA9IGN1cnJlbnQubmFtZTtcbiAgICAgIG5leHQucGFyYW1zID0gcGFyYW1zO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5tYXRjaGVkLmxlbmd0aCkge1xuICAgICAgdmFyIHJhd1BhdGggPSBjdXJyZW50Lm1hdGNoZWRbY3VycmVudC5tYXRjaGVkLmxlbmd0aCAtIDFdLnBhdGg7XG4gICAgICBuZXh0LnBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicGF0aCBcIiArIChjdXJyZW50LnBhdGgpKSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCBcInJlbGF0aXZlIHBhcmFtcyBuYXZpZ2F0aW9uIHJlcXVpcmVzIGEgY3VycmVudCByb3V0ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICB2YXIgcGFyc2VkUGF0aCA9IHBhcnNlUGF0aChuZXh0LnBhdGggfHwgJycpO1xuICB2YXIgYmFzZVBhdGggPSAoY3VycmVudCAmJiBjdXJyZW50LnBhdGgpIHx8ICcvJztcbiAgdmFyIHBhdGggPSBwYXJzZWRQYXRoLnBhdGhcbiAgICA/IHJlc29sdmVQYXRoKHBhcnNlZFBhdGgucGF0aCwgYmFzZVBhdGgsIGFwcGVuZCB8fCBuZXh0LmFwcGVuZClcbiAgICA6IGJhc2VQYXRoO1xuXG4gIHZhciBxdWVyeSA9IHJlc29sdmVRdWVyeShcbiAgICBwYXJzZWRQYXRoLnF1ZXJ5LFxuICAgIG5leHQucXVlcnksXG4gICAgcm91dGVyICYmIHJvdXRlci5vcHRpb25zLnBhcnNlUXVlcnlcbiAgKTtcblxuICB2YXIgaGFzaCA9IG5leHQuaGFzaCB8fCBwYXJzZWRQYXRoLmhhc2g7XG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIHtcbiAgICBoYXNoID0gXCIjXCIgKyBoYXNoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBoYXNoOiBoYXNoXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduIChhLCBiKSB7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgYVtrZXldID0gYltrZXldO1xuICB9XG4gIHJldHVybiBhXG59XG5cbi8qICAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIgKFxuICByb3V0ZXMsXG4gIHJvdXRlclxuKSB7XG4gIHZhciByZWYgPSBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMpO1xuICB2YXIgcGF0aExpc3QgPSByZWYucGF0aExpc3Q7XG4gIHZhciBwYXRoTWFwID0gcmVmLnBhdGhNYXA7XG4gIHZhciBuYW1lTWFwID0gcmVmLm5hbWVNYXA7XG5cbiAgZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcbiAgICBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMsIHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoIChcbiAgICByYXcsXG4gICAgY3VycmVudFJvdXRlLFxuICAgIHJlZGlyZWN0ZWRGcm9tXG4gICkge1xuICAgIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKHJhdywgY3VycmVudFJvdXRlLCBmYWxzZSwgcm91dGVyKTtcbiAgICB2YXIgbmFtZSA9IGxvY2F0aW9uLm5hbWU7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgdmFyIHJlY29yZCA9IG5hbWVNYXBbbmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKHJlY29yZCwgKFwiUm91dGUgd2l0aCBuYW1lICdcIiArIG5hbWUgKyBcIicgZG9lcyBub3QgZXhpc3RcIikpO1xuICAgICAgfVxuICAgICAgaWYgKCFyZWNvcmQpIHsgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbikgfVxuICAgICAgdmFyIHBhcmFtTmFtZXMgPSByZWNvcmQucmVnZXgua2V5c1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFrZXkub3B0aW9uYWw7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5Lm5hbWU7IH0pO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uLnBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50Um91dGUgJiYgdHlwZW9mIGN1cnJlbnRSb3V0ZS5wYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50Um91dGUucGFyYW1zKSB7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIGxvY2F0aW9uLnBhcmFtcykgJiYgcGFyYW1OYW1lcy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgbG9jYXRpb24ucGFyYW1zW2tleV0gPSBjdXJyZW50Um91dGUucGFyYW1zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgbG9jYXRpb24ucGF0aCA9IGZpbGxQYXJhbXMocmVjb3JkLnBhdGgsIGxvY2F0aW9uLnBhcmFtcywgKFwibmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRoKSB7XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoTGlzdFtpXTtcbiAgICAgICAgdmFyIHJlY29yZCQxID0gcGF0aE1hcFtwYXRoXTtcbiAgICAgICAgaWYgKG1hdGNoUm91dGUocmVjb3JkJDEucmVnZXgsIGxvY2F0aW9uLnBhdGgsIGxvY2F0aW9uLnBhcmFtcykpIHtcbiAgICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCQxLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm8gbWF0Y2hcbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVkaXJlY3QgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvblxuICApIHtcbiAgICB2YXIgb3JpZ2luYWxSZWRpcmVjdCA9IHJlY29yZC5yZWRpcmVjdDtcbiAgICB2YXIgcmVkaXJlY3QgPSB0eXBlb2Ygb3JpZ2luYWxSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9yaWdpbmFsUmVkaXJlY3QoY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgbnVsbCwgcm91dGVyKSlcbiAgICAgICAgOiBvcmlnaW5hbFJlZGlyZWN0O1xuXG4gICAgaWYgKHR5cGVvZiByZWRpcmVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlZGlyZWN0ID0geyBwYXRoOiByZWRpcmVjdCB9O1xuICAgIH1cblxuICAgIGlmICghcmVkaXJlY3QgfHwgdHlwZW9mIHJlZGlyZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICAgIH1cblxuICAgIHZhciByZSA9IHJlZGlyZWN0O1xuICAgIHZhciBuYW1lID0gcmUubmFtZTtcbiAgICB2YXIgcGF0aCA9IHJlLnBhdGg7XG4gICAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnk7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICAgIHZhciBwYXJhbXMgPSBsb2NhdGlvbi5wYXJhbXM7XG4gICAgcXVlcnkgPSByZS5oYXNPd25Qcm9wZXJ0eSgncXVlcnknKSA/IHJlLnF1ZXJ5IDogcXVlcnk7XG4gICAgaGFzaCA9IHJlLmhhc093blByb3BlcnR5KCdoYXNoJykgPyByZS5oYXNoIDogaGFzaDtcbiAgICBwYXJhbXMgPSByZS5oYXNPd25Qcm9wZXJ0eSgncGFyYW1zJykgPyByZS5wYXJhbXMgOiBwYXJhbXM7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgLy8gcmVzb2x2ZWQgbmFtZWQgZGlyZWN0XG4gICAgICB2YXIgdGFyZ2V0UmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydCh0YXJnZXRSZWNvcmQsIChcInJlZGlyZWN0IGZhaWxlZDogbmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBub3QgZm91bmQuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICB9LCB1bmRlZmluZWQsIGxvY2F0aW9uKVxuICAgIH0gZWxzZSBpZiAocGF0aCkge1xuICAgICAgLy8gMS4gcmVzb2x2ZSByZWxhdGl2ZSByZWRpcmVjdFxuICAgICAgdmFyIHJhd1BhdGggPSByZXNvbHZlUmVjb3JkUGF0aChwYXRoLCByZWNvcmQpO1xuICAgICAgLy8gMi4gcmVzb2x2ZSBwYXJhbXNcbiAgICAgIHZhciByZXNvbHZlZFBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicmVkaXJlY3Qgcm91dGUgd2l0aCBwYXRoIFxcXCJcIiArIHJhd1BhdGggKyBcIlxcXCJcIikpO1xuICAgICAgLy8gMy4gcmVtYXRjaCB3aXRoIGV4aXN0aW5nIHF1ZXJ5IGFuZCBoYXNoXG4gICAgICByZXR1cm4gbWF0Y2goe1xuICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgICAgcGF0aDogcmVzb2x2ZWRQYXRoLFxuICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIGhhc2g6IGhhc2hcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oZmFsc2UsIChcImludmFsaWQgcmVkaXJlY3Qgb3B0aW9uOiBcIiArIChKU09OLnN0cmluZ2lmeShyZWRpcmVjdCkpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFsaWFzIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgbWF0Y2hBc1xuICApIHtcbiAgICB2YXIgYWxpYXNlZFBhdGggPSBmaWxsUGFyYW1zKG1hdGNoQXMsIGxvY2F0aW9uLnBhcmFtcywgKFwiYWxpYXNlZCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgbWF0Y2hBcyArIFwiXFxcIlwiKSk7XG4gICAgdmFyIGFsaWFzZWRNYXRjaCA9IG1hdGNoKHtcbiAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgcGF0aDogYWxpYXNlZFBhdGhcbiAgICB9KTtcbiAgICBpZiAoYWxpYXNlZE1hdGNoKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9IGFsaWFzZWRNYXRjaC5tYXRjaGVkO1xuICAgICAgdmFyIGFsaWFzZWRSZWNvcmQgPSBtYXRjaGVkW21hdGNoZWQubGVuZ3RoIC0gMV07XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSBhbGlhc2VkTWF0Y2gucGFyYW1zO1xuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShhbGlhc2VkUmVjb3JkLCBsb2NhdGlvbilcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVSb3V0ZSAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uLFxuICAgIHJlZGlyZWN0ZWRGcm9tXG4gICkge1xuICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLnJlZGlyZWN0KSB7XG4gICAgICByZXR1cm4gcmVkaXJlY3QocmVjb3JkLCByZWRpcmVjdGVkRnJvbSB8fCBsb2NhdGlvbilcbiAgICB9XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQubWF0Y2hBcykge1xuICAgICAgcmV0dXJuIGFsaWFzKHJlY29yZCwgbG9jYXRpb24sIHJlY29yZC5tYXRjaEFzKVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20sIHJvdXRlcilcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIGFkZFJvdXRlczogYWRkUm91dGVzXG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZSAoXG4gIHJlZ2V4LFxuICBwYXRoLFxuICBwYXJhbXNcbikge1xuICB2YXIgbSA9IHBhdGgubWF0Y2gocmVnZXgpO1xuXG4gIGlmICghbSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IG0ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIga2V5ID0gcmVnZXgua2V5c1tpIC0gMV07XG4gICAgdmFyIHZhbCA9IHR5cGVvZiBtW2ldID09PSAnc3RyaW5nJyA/IGRlY29kZVVSSUNvbXBvbmVudChtW2ldKSA6IG1baV07XG4gICAgaWYgKGtleSkge1xuICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUmVjb3JkUGF0aCAocGF0aCwgcmVjb3JkKSB7XG4gIHJldHVybiByZXNvbHZlUGF0aChwYXRoLCByZWNvcmQucGFyZW50ID8gcmVjb3JkLnBhcmVudC5wYXRoIDogJy8nLCB0cnVlKVxufVxuXG4vKiAgKi9cblxuXG52YXIgcG9zaXRpb25TdG9yZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIHNldHVwU2Nyb2xsICgpIHtcbiAgLy8gRml4IGZvciAjMTU4NSBmb3IgRmlyZWZveFxuICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IGdldFN0YXRlS2V5KCkgfSwgJycpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xuICAgIGlmIChlLnN0YXRlICYmIGUuc3RhdGUua2V5KSB7XG4gICAgICBzZXRTdGF0ZUtleShlLnN0YXRlLmtleSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU2Nyb2xsIChcbiAgcm91dGVyLFxuICB0byxcbiAgZnJvbSxcbiAgaXNQb3Bcbikge1xuICBpZiAoIXJvdXRlci5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiZWhhdmlvciA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuICBpZiAoIWJlaGF2aW9yKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydCh0eXBlb2YgYmVoYXZpb3IgPT09ICdmdW5jdGlvbicsIFwic2Nyb2xsQmVoYXZpb3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgLy8gd2FpdCB1bnRpbCByZS1yZW5kZXIgZmluaXNoZXMgYmVmb3JlIHNjcm9sbGluZ1xuICByb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB2YXIgc2hvdWxkU2Nyb2xsID0gYmVoYXZpb3IodG8sIGZyb20sIGlzUG9wID8gcG9zaXRpb24gOiBudWxsKTtcblxuICAgIGlmICghc2hvdWxkU2Nyb2xsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNob3VsZFNjcm9sbC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzaG91bGRTY3JvbGwudGhlbihmdW5jdGlvbiAoc2hvdWxkU2Nyb2xsKSB7XG4gICAgICAgIHNjcm9sbFRvUG9zaXRpb24oKHNob3VsZFNjcm9sbCksIHBvc2l0aW9uKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBhc3NlcnQoZmFsc2UsIGVyci50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcm9sbFRvUG9zaXRpb24oc2hvdWxkU2Nyb2xsLCBwb3NpdGlvbik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uICgpIHtcbiAgdmFyIGtleSA9IGdldFN0YXRlS2V5KCk7XG4gIGlmIChrZXkpIHtcbiAgICBwb3NpdGlvblN0b3JlW2tleV0gPSB7XG4gICAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFBvc2l0aW9uICgpIHtcbiAgdmFyIGtleSA9IGdldFN0YXRlS2V5KCk7XG4gIGlmIChrZXkpIHtcbiAgICByZXR1cm4gcG9zaXRpb25TdG9yZVtrZXldXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudFBvc2l0aW9uIChlbCwgb2Zmc2V0KSB7XG4gIHZhciBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGRvY1JlY3QgPSBkb2NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIHg6IGVsUmVjdC5sZWZ0IC0gZG9jUmVjdC5sZWZ0IC0gb2Zmc2V0LngsXG4gICAgeTogZWxSZWN0LnRvcCAtIGRvY1JlY3QudG9wIC0gb2Zmc2V0LnlcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUG9zaXRpb24gKG9iaikge1xuICByZXR1cm4gaXNOdW1iZXIob2JqLngpIHx8IGlzTnVtYmVyKG9iai55KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgeDogaXNOdW1iZXIob2JqLngpID8gb2JqLnggOiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgeTogaXNOdW1iZXIob2JqLnkpID8gb2JqLnkgOiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPZmZzZXQgKG9iaikge1xuICByZXR1cm4ge1xuICAgIHg6IGlzTnVtYmVyKG9iai54KSA/IG9iai54IDogMCxcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IDBcbiAgfVxufVxuXG5mdW5jdGlvbiBpc051bWJlciAodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHNjcm9sbFRvUG9zaXRpb24gKHNob3VsZFNjcm9sbCwgcG9zaXRpb24pIHtcbiAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIHNob3VsZFNjcm9sbCA9PT0gJ29iamVjdCc7XG4gIGlmIChpc09iamVjdCAmJiB0eXBlb2Ygc2hvdWxkU2Nyb2xsLnNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2hvdWxkU2Nyb2xsLnNlbGVjdG9yKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBzaG91bGRTY3JvbGwub2Zmc2V0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwub2Zmc2V0ID09PSAnb2JqZWN0JyA/IHNob3VsZFNjcm9sbC5vZmZzZXQgOiB7fTtcbiAgICAgIG9mZnNldCA9IG5vcm1hbGl6ZU9mZnNldChvZmZzZXQpO1xuICAgICAgcG9zaXRpb24gPSBnZXRFbGVtZW50UG9zaXRpb24oZWwsIG9mZnNldCk7XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCAmJiBpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcbiAgfVxuXG4gIGlmIChwb3NpdGlvbikge1xuICAgIHdpbmRvdy5zY3JvbGxUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gaW5Ccm93c2VyICYmIChmdW5jdGlvbiAoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmIChcbiAgICAodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiZcbiAgICB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmXG4gICAgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmXG4gICAgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMVxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeVxufSkoKTtcblxuLy8gdXNlIFVzZXIgVGltaW5nIGFwaSAoaWYgcHJlc2VudCkgZm9yIG1vcmUgYWNjdXJhdGUga2V5IHByZWNpc2lvblxudmFyIFRpbWUgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3dcbiAgPyB3aW5kb3cucGVyZm9ybWFuY2VcbiAgOiBEYXRlO1xuXG52YXIgX2tleSA9IGdlbktleSgpO1xuXG5mdW5jdGlvbiBnZW5LZXkgKCkge1xuICByZXR1cm4gVGltZS5ub3coKS50b0ZpeGVkKDMpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlS2V5ICgpIHtcbiAgcmV0dXJuIF9rZXlcbn1cblxuZnVuY3Rpb24gc2V0U3RhdGVLZXkgKGtleSkge1xuICBfa2V5ID0ga2V5O1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhdGUgKHVybCwgcmVwbGFjZSkge1xuICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgLy8gdHJ5Li4uY2F0Y2ggdGhlIHB1c2hTdGF0ZSBjYWxsIHRvIGdldCBhcm91bmQgU2FmYXJpXG4gIC8vIERPTSBFeGNlcHRpb24gMTggd2hlcmUgaXQgbGltaXRzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHNcbiAgdmFyIGhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdHJ5IHtcbiAgICBpZiAocmVwbGFjZSkge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9rZXkgPSBnZW5LZXkoKTtcbiAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ2Fzc2lnbiddKHVybCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZVN0YXRlICh1cmwpIHtcbiAgcHVzaFN0YXRlKHVybCwgdHJ1ZSk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBydW5RdWV1ZSAocXVldWUsIGZuLCBjYikge1xuICB2YXIgc3RlcCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNiKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChxdWV1ZVtpbmRleF0pIHtcbiAgICAgICAgZm4ocXVldWVbaW5kZXhdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RlcChpbmRleCArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0ZXAoMCk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnRzIChtYXRjaGVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodG8sIGZyb20sIG5leHQpIHtcbiAgICB2YXIgaGFzQXN5bmMgPSBmYWxzZTtcbiAgICB2YXIgcGVuZGluZyA9IDA7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcblxuICAgIGZsYXRNYXBDb21wb25lbnRzKG1hdGNoZWQsIGZ1bmN0aW9uIChkZWYsIF8sIG1hdGNoLCBrZXkpIHtcbiAgICAgIC8vIGlmIGl0J3MgYSBmdW5jdGlvbiBhbmQgZG9lc24ndCBoYXZlIGNpZCBhdHRhY2hlZCxcbiAgICAgIC8vIGFzc3VtZSBpdCdzIGFuIGFzeW5jIGNvbXBvbmVudCByZXNvbHZlIGZ1bmN0aW9uLlxuICAgICAgLy8gd2UgYXJlIG5vdCB1c2luZyBWdWUncyBkZWZhdWx0IGFzeW5jIHJlc29sdmluZyBtZWNoYW5pc20gYmVjYXVzZVxuICAgICAgLy8gd2Ugd2FudCB0byBoYWx0IHRoZSBuYXZpZ2F0aW9uIHVudGlsIHRoZSBpbmNvbWluZyBjb21wb25lbnQgaGFzIGJlZW5cbiAgICAgIC8vIHJlc29sdmVkLlxuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZGVmLmNpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhhc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgcGVuZGluZysrO1xuXG4gICAgICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzb2x2ZWREZWYpIHtcbiAgICAgICAgICBpZiAoaXNFU01vZHVsZShyZXNvbHZlZERlZikpIHtcbiAgICAgICAgICAgIHJlc29sdmVkRGVmID0gcmVzb2x2ZWREZWYuZGVmYXVsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc2F2ZSByZXNvbHZlZCBvbiBhc3luYyBmYWN0b3J5IGluIGNhc2UgaXQncyB1c2VkIGVsc2V3aGVyZVxuICAgICAgICAgIGRlZi5yZXNvbHZlZCA9IHR5cGVvZiByZXNvbHZlZERlZiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyByZXNvbHZlZERlZlxuICAgICAgICAgICAgOiBfVnVlLmV4dGVuZChyZXNvbHZlZERlZik7XG4gICAgICAgICAgbWF0Y2guY29tcG9uZW50c1trZXldID0gcmVzb2x2ZWREZWY7XG4gICAgICAgICAgcGVuZGluZy0tO1xuICAgICAgICAgIGlmIChwZW5kaW5nIDw9IDApIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICB2YXIgbXNnID0gXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQgXCIgKyBrZXkgKyBcIjogXCIgKyByZWFzb247XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBtc2cpO1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yID0gaXNFcnJvcihyZWFzb24pXG4gICAgICAgICAgICAgID8gcmVhc29uXG4gICAgICAgICAgICAgIDogbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICBuZXh0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzID0gZGVmKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5ldyBzeW50YXggaW4gVnVlIDIuM1xuICAgICAgICAgICAgdmFyIGNvbXAgPSByZXMuY29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXAgJiYgdHlwZW9mIGNvbXAudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBjb21wLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghaGFzQXN5bmMpIHsgbmV4dCgpOyB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdE1hcENvbXBvbmVudHMgKFxuICBtYXRjaGVkLFxuICBmblxuKSB7XG4gIHJldHVybiBmbGF0dGVuKG1hdGNoZWQubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG0uY29tcG9uZW50cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKFxuICAgICAgbS5jb21wb25lbnRzW2tleV0sXG4gICAgICBtLmluc3RhbmNlc1trZXldLFxuICAgICAgbSwga2V5XG4gICAgKTsgfSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4gKGFycikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxuZnVuY3Rpb24gaXNFU01vZHVsZSAob2JqKSB7XG4gIHJldHVybiBvYmouX19lc01vZHVsZSB8fCAoaGFzU3ltYm9sICYmIG9ialtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbn1cblxuLy8gaW4gV2VicGFjayAyLCByZXF1aXJlLmVuc3VyZSBub3cgYWxzbyByZXR1cm5zIGEgUHJvbWlzZVxuLy8gc28gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9ucyBtYXkgZ2V0IGNhbGxlZCBhbiBleHRyYSB0aW1lXG4vLyBpZiB0aGUgdXNlciB1c2VzIGFuIGFycm93IGZ1bmN0aW9uIHNob3J0aGFuZCB0aGF0IGhhcHBlbnMgdG9cbi8vIHJldHVybiB0aGF0IFByb21pc2UuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgaWYgKGNhbGxlZCkgeyByZXR1cm4gfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBIaXN0b3J5ID0gZnVuY3Rpb24gSGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gIHRoaXMucm91dGVyID0gcm91dGVyO1xuICB0aGlzLmJhc2UgPSBub3JtYWxpemVCYXNlKGJhc2UpO1xuICAvLyBzdGFydCB3aXRoIGEgcm91dGUgb2JqZWN0IHRoYXQgc3RhbmRzIGZvciBcIm5vd2hlcmVcIlxuICB0aGlzLmN1cnJlbnQgPSBTVEFSVDtcbiAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICB0aGlzLnJlYWR5Q2JzID0gW107XG4gIHRoaXMucmVhZHlFcnJvckNicyA9IFtdO1xuICB0aGlzLmVycm9yQ2JzID0gW107XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4gKGNiKSB7XG4gIHRoaXMuY2IgPSBjYjtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYiwgZXJyb3JDYikge1xuICBpZiAodGhpcy5yZWFkeSkge1xuICAgIGNiKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWFkeUNicy5wdXNoKGNiKTtcbiAgICBpZiAoZXJyb3JDYikge1xuICAgICAgdGhpcy5yZWFkeUVycm9yQ2JzLnB1c2goZXJyb3JDYik7XG4gICAgfVxuICB9XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvciAoZXJyb3JDYikge1xuICB0aGlzLmVycm9yQ2JzLnB1c2goZXJyb3JDYik7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS50cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiB0cmFuc2l0aW9uVG8gKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHJvdXRlID0gdGhpcy5yb3V0ZXIubWF0Y2gobG9jYXRpb24sIHRoaXMuY3VycmVudCk7XG4gIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgdGhpcyQxLmVuc3VyZVVSTCgpO1xuXG4gICAgLy8gZmlyZSByZWFkeSBjYnMgb25jZVxuICAgIGlmICghdGhpcyQxLnJlYWR5KSB7XG4gICAgICB0aGlzJDEucmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcyQxLnJlYWR5Q2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKHJvdXRlKTsgfSk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKG9uQWJvcnQpIHtcbiAgICAgIG9uQWJvcnQoZXJyKTtcbiAgICB9XG4gICAgaWYgKGVyciAmJiAhdGhpcyQxLnJlYWR5KSB7XG4gICAgICB0aGlzJDEucmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcyQxLnJlYWR5RXJyb3JDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2IoZXJyKTsgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLmNvbmZpcm1UcmFuc2l0aW9uID0gZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb24gKHJvdXRlLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gIHZhciBhYm9ydCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoaXNFcnJvcihlcnIpKSB7XG4gICAgICBpZiAodGhpcyQxLmVycm9yQ2JzLmxlbmd0aCkge1xuICAgICAgICB0aGlzJDEuZXJyb3JDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2IoZXJyKTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKGZhbHNlLCAndW5jYXVnaHQgZXJyb3IgZHVyaW5nIHJvdXRlIG5hdmlnYXRpb246Jyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb25BYm9ydCAmJiBvbkFib3J0KGVycik7XG4gIH07XG4gIGlmIChcbiAgICBpc1NhbWVSb3V0ZShyb3V0ZSwgY3VycmVudCkgJiZcbiAgICAvLyBpbiB0aGUgY2FzZSB0aGUgcm91dGUgbWFwIGhhcyBiZWVuIGR5bmFtaWNhbGx5IGFwcGVuZGVkIHRvXG4gICAgcm91dGUubWF0Y2hlZC5sZW5ndGggPT09IGN1cnJlbnQubWF0Y2hlZC5sZW5ndGhcbiAgKSB7XG4gICAgdGhpcy5lbnN1cmVVUkwoKTtcbiAgICByZXR1cm4gYWJvcnQoKVxuICB9XG5cbiAgdmFyIHJlZiA9IHJlc29sdmVRdWV1ZSh0aGlzLmN1cnJlbnQubWF0Y2hlZCwgcm91dGUubWF0Y2hlZCk7XG4gICAgdmFyIHVwZGF0ZWQgPSByZWYudXBkYXRlZDtcbiAgICB2YXIgZGVhY3RpdmF0ZWQgPSByZWYuZGVhY3RpdmF0ZWQ7XG4gICAgdmFyIGFjdGl2YXRlZCA9IHJlZi5hY3RpdmF0ZWQ7XG5cbiAgdmFyIHF1ZXVlID0gW10uY29uY2F0KFxuICAgIC8vIGluLWNvbXBvbmVudCBsZWF2ZSBndWFyZHNcbiAgICBleHRyYWN0TGVhdmVHdWFyZHMoZGVhY3RpdmF0ZWQpLFxuICAgIC8vIGdsb2JhbCBiZWZvcmUgaG9va3NcbiAgICB0aGlzLnJvdXRlci5iZWZvcmVIb29rcyxcbiAgICAvLyBpbi1jb21wb25lbnQgdXBkYXRlIGhvb2tzXG4gICAgZXh0cmFjdFVwZGF0ZUhvb2tzKHVwZGF0ZWQpLFxuICAgIC8vIGluLWNvbmZpZyBlbnRlciBndWFyZHNcbiAgICBhY3RpdmF0ZWQubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmJlZm9yZUVudGVyOyB9KSxcbiAgICAvLyBhc3luYyBjb21wb25lbnRzXG4gICAgcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyhhY3RpdmF0ZWQpXG4gICk7XG5cbiAgdGhpcy5wZW5kaW5nID0gcm91dGU7XG4gIHZhciBpdGVyYXRvciA9IGZ1bmN0aW9uIChob29rLCBuZXh0KSB7XG4gICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgcmV0dXJuIGFib3J0KClcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGhvb2socm91dGUsIGN1cnJlbnQsIGZ1bmN0aW9uICh0bykge1xuICAgICAgICBpZiAodG8gPT09IGZhbHNlIHx8IGlzRXJyb3IodG8pKSB7XG4gICAgICAgICAgLy8gbmV4dChmYWxzZSkgLT4gYWJvcnQgbmF2aWdhdGlvbiwgZW5zdXJlIGN1cnJlbnQgVVJMXG4gICAgICAgICAgdGhpcyQxLmVuc3VyZVVSTCh0cnVlKTtcbiAgICAgICAgICBhYm9ydCh0byk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgdHlwZW9mIHRvID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICh0eXBlb2YgdG8gPT09ICdvYmplY3QnICYmIChcbiAgICAgICAgICAgIHR5cGVvZiB0by5wYXRoID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHRvLm5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gbmV4dCgnLycpIG9yIG5leHQoeyBwYXRoOiAnLycgfSkgLT4gcmVkaXJlY3RcbiAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIGlmICh0eXBlb2YgdG8gPT09ICdvYmplY3QnICYmIHRvLnJlcGxhY2UpIHtcbiAgICAgICAgICAgIHRoaXMkMS5yZXBsYWNlKHRvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcyQxLnB1c2godG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb25maXJtIHRyYW5zaXRpb24gYW5kIHBhc3Mgb24gdGhlIHZhbHVlXG4gICAgICAgICAgbmV4dCh0byk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGFib3J0KGUpO1xuICAgIH1cbiAgfTtcblxuICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zdEVudGVyQ2JzID0gW107XG4gICAgdmFyIGlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuY3VycmVudCA9PT0gcm91dGU7IH07XG4gICAgLy8gd2FpdCB1bnRpbCBhc3luYyBjb21wb25lbnRzIGFyZSByZXNvbHZlZCBiZWZvcmVcbiAgICAvLyBleHRyYWN0aW5nIGluLWNvbXBvbmVudCBlbnRlciBndWFyZHNcbiAgICB2YXIgZW50ZXJHdWFyZHMgPSBleHRyYWN0RW50ZXJHdWFyZHMoYWN0aXZhdGVkLCBwb3N0RW50ZXJDYnMsIGlzVmFsaWQpO1xuICAgIHZhciBxdWV1ZSA9IGVudGVyR3VhcmRzLmNvbmNhdCh0aGlzJDEucm91dGVyLnJlc29sdmVIb29rcyk7XG4gICAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcyQxLnBlbmRpbmcgIT09IHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBhYm9ydCgpXG4gICAgICB9XG4gICAgICB0aGlzJDEucGVuZGluZyA9IG51bGw7XG4gICAgICBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICAgIGlmICh0aGlzJDEucm91dGVyLmFwcCkge1xuICAgICAgICB0aGlzJDEucm91dGVyLmFwcC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBvc3RFbnRlckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYigpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudXBkYXRlUm91dGUgPSBmdW5jdGlvbiB1cGRhdGVSb3V0ZSAocm91dGUpIHtcbiAgdmFyIHByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gIHRoaXMuY3VycmVudCA9IHJvdXRlO1xuICB0aGlzLmNiICYmIHRoaXMuY2Iocm91dGUpO1xuICB0aGlzLnJvdXRlci5hZnRlckhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rICYmIGhvb2socm91dGUsIHByZXYpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJhc2UgKGJhc2UpIHtcbiAgaWYgKCFiYXNlKSB7XG4gICAgaWYgKGluQnJvd3Nlcikge1xuICAgICAgLy8gcmVzcGVjdCA8YmFzZT4gdGFnXG4gICAgICB2YXIgYmFzZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgICAgYmFzZSA9IChiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB8fCAnLyc7XG4gICAgICAvLyBzdHJpcCBmdWxsIFVSTCBvcmlnaW5cbiAgICAgIGJhc2UgPSBiYXNlLnJlcGxhY2UoL15odHRwcz86XFwvXFwvW15cXC9dKy8sICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSA9ICcvJztcbiAgICB9XG4gIH1cbiAgLy8gbWFrZSBzdXJlIHRoZXJlJ3MgdGhlIHN0YXJ0aW5nIHNsYXNoXG4gIGlmIChiYXNlLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgYmFzZSA9ICcvJyArIGJhc2U7XG4gIH1cbiAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gIHJldHVybiBiYXNlLnJlcGxhY2UoL1xcLyQvLCAnJylcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXVlIChcbiAgY3VycmVudCxcbiAgbmV4dFxuKSB7XG4gIHZhciBpO1xuICB2YXIgbWF4ID0gTWF0aC5tYXgoY3VycmVudC5sZW5ndGgsIG5leHQubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgaWYgKGN1cnJlbnRbaV0gIT09IG5leHRbaV0pIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdXBkYXRlZDogbmV4dC5zbGljZSgwLCBpKSxcbiAgICBhY3RpdmF0ZWQ6IG5leHQuc2xpY2UoaSksXG4gICAgZGVhY3RpdmF0ZWQ6IGN1cnJlbnQuc2xpY2UoaSlcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0R3VhcmRzIChcbiAgcmVjb3JkcyxcbiAgbmFtZSxcbiAgYmluZCxcbiAgcmV2ZXJzZVxuKSB7XG4gIHZhciBndWFyZHMgPSBmbGF0TWFwQ29tcG9uZW50cyhyZWNvcmRzLCBmdW5jdGlvbiAoZGVmLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSkge1xuICAgIHZhciBndWFyZCA9IGV4dHJhY3RHdWFyZChkZWYsIG5hbWUpO1xuICAgIGlmIChndWFyZCkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZ3VhcmQpXG4gICAgICAgID8gZ3VhcmQubWFwKGZ1bmN0aW9uIChndWFyZCkgeyByZXR1cm4gYmluZChndWFyZCwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpOyB9KVxuICAgICAgICA6IGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmbGF0dGVuKHJldmVyc2UgPyBndWFyZHMucmV2ZXJzZSgpIDogZ3VhcmRzKVxufVxuXG5mdW5jdGlvbiBleHRyYWN0R3VhcmQgKFxuICBkZWYsXG4gIGtleVxuKSB7XG4gIGlmICh0eXBlb2YgZGVmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZXh0ZW5kIG5vdyBzbyB0aGF0IGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQuXG4gICAgZGVmID0gX1Z1ZS5leHRlbmQoZGVmKTtcbiAgfVxuICByZXR1cm4gZGVmLm9wdGlvbnNba2V5XVxufVxuXG5mdW5jdGlvbiBleHRyYWN0TGVhdmVHdWFyZHMgKGRlYWN0aXZhdGVkKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKGRlYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVMZWF2ZScsIGJpbmRHdWFyZCwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFVwZGF0ZUhvb2tzICh1cGRhdGVkKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKHVwZGF0ZWQsICdiZWZvcmVSb3V0ZVVwZGF0ZScsIGJpbmRHdWFyZClcbn1cblxuZnVuY3Rpb24gYmluZEd1YXJkIChndWFyZCwgaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kUm91dGVHdWFyZCAoKSB7XG4gICAgICByZXR1cm4gZ3VhcmQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVudGVyR3VhcmRzIChcbiAgYWN0aXZhdGVkLFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhhY3RpdmF0ZWQsICdiZWZvcmVSb3V0ZUVudGVyJywgZnVuY3Rpb24gKGd1YXJkLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgcmV0dXJuIGJpbmRFbnRlckd1YXJkKGd1YXJkLCBtYXRjaCwga2V5LCBjYnMsIGlzVmFsaWQpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGJpbmRFbnRlckd1YXJkIChcbiAgZ3VhcmQsXG4gIG1hdGNoLFxuICBrZXksXG4gIGNicyxcbiAgaXNWYWxpZFxuKSB7XG4gIHJldHVybiBmdW5jdGlvbiByb3V0ZUVudGVyR3VhcmQgKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgcmV0dXJuIGd1YXJkKHRvLCBmcm9tLCBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIG5leHQoY2IpO1xuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gIzc1MFxuICAgICAgICAgIC8vIGlmIGEgcm91dGVyLXZpZXcgaXMgd3JhcHBlZCB3aXRoIGFuIG91dC1pbiB0cmFuc2l0aW9uLFxuICAgICAgICAgIC8vIHRoZSBpbnN0YW5jZSBtYXkgbm90IGhhdmUgYmVlbiByZWdpc3RlcmVkIGF0IHRoaXMgdGltZS5cbiAgICAgICAgICAvLyB3ZSB3aWxsIG5lZWQgdG8gcG9sbCBmb3IgcmVnaXN0cmF0aW9uIHVudGlsIGN1cnJlbnQgcm91dGVcbiAgICAgICAgICAvLyBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgICAgICAgcG9sbChjYiwgbWF0Y2guaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvbGwgKFxuICBjYiwgLy8gc29tZWhvdyBmbG93IGNhbm5vdCBpbmZlciB0aGlzIGlzIGEgZnVuY3Rpb25cbiAgaW5zdGFuY2VzLFxuICBrZXksXG4gIGlzVmFsaWRcbikge1xuICBpZiAoaW5zdGFuY2VzW2tleV0pIHtcbiAgICBjYihpbnN0YW5jZXNba2V5XSk7XG4gIH0gZWxzZSBpZiAoaXNWYWxpZCgpKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBwb2xsKGNiLCBpbnN0YW5jZXMsIGtleSwgaXNWYWxpZCk7XG4gICAgfSwgMTYpO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBIVE1MNUhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gSFRNTDVIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuXG4gICAgdmFyIGV4cGVjdFNjcm9sbCA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuXG4gICAgaWYgKGV4cGVjdFNjcm9sbCkge1xuICAgICAgc2V0dXBTY3JvbGwoKTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdExvY2F0aW9uID0gZ2V0TG9jYXRpb24odGhpcy5iYXNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzJDEuY3VycmVudDtcblxuICAgICAgLy8gQXZvaWRpbmcgZmlyc3QgYHBvcHN0YXRlYCBldmVudCBkaXNwYXRjaGVkIGluIHNvbWUgYnJvd3NlcnMgYnV0IGZpcnN0XG4gICAgICAvLyBoaXN0b3J5IHJvdXRlIG5vdCB1cGRhdGVkIHNpbmNlIGFzeW5jIGd1YXJkIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbih0aGlzJDEuYmFzZSk7XG4gICAgICBpZiAodGhpcyQxLmN1cnJlbnQgPT09IFNUQVJUICYmIGxvY2F0aW9uID09PSBpbml0TG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAoZXhwZWN0U2Nyb2xsKSB7XG4gICAgICAgICAgaGFuZGxlU2Nyb2xsKHJvdXRlciwgcm91dGUsIGN1cnJlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEhUTUw1SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSFRNTDVIaXN0b3J5O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcHVzaFN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHJlcGxhY2VTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcbiAgICBpZiAoZ2V0TG9jYXRpb24odGhpcy5iYXNlKSAhPT0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGNsZWFuUGF0aCh0aGlzLmJhc2UgKyB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpO1xuICAgICAgcHVzaCA/IHB1c2hTdGF0ZShjdXJyZW50KSA6IHJlcGxhY2VTdGF0ZShjdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHJldHVybiBnZXRMb2NhdGlvbih0aGlzLmJhc2UpXG4gIH07XG5cbiAgcmV0dXJuIEhUTUw1SGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG5mdW5jdGlvbiBnZXRMb2NhdGlvbiAoYmFzZSkge1xuICB2YXIgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgaWYgKGJhc2UgJiYgcGF0aC5pbmRleE9mKGJhc2UpID09PSAwKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZS5sZW5ndGgpO1xuICB9XG4gIHJldHVybiAocGF0aCB8fCAnLycpICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIHdpbmRvdy5sb2NhdGlvbi5oYXNoXG59XG5cbi8qICAqL1xuXG5cbnZhciBIYXNoSGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBIYXNoSGlzdG9yeSAocm91dGVyLCBiYXNlLCBmYWxsYmFjaykge1xuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIC8vIGNoZWNrIGhpc3RvcnkgZmFsbGJhY2sgZGVlcGxpbmtpbmdcbiAgICBpZiAoZmFsbGJhY2sgJiYgY2hlY2tGYWxsYmFjayh0aGlzLmJhc2UpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZW5zdXJlU2xhc2goKTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEhhc2hIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGFzaEhpc3Rvcnk7XG5cbiAgLy8gdGhpcyBpcyBkZWxheWVkIHVudGlsIHRoZSBhcHAgbW91bnRzXG4gIC8vIHRvIGF2b2lkIHRoZSBoYXNoY2hhbmdlIGxpc3RlbmVyIGJlaW5nIGZpcmVkIHRvbyBlYXJseVxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuc2V0dXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXR1cExpc3RlbmVycyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy5yb3V0ZXI7XG4gICAgdmFyIGV4cGVjdFNjcm9sbCA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuICAgIHZhciBzdXBwb3J0c1Njcm9sbCA9IHN1cHBvcnRzUHVzaFN0YXRlICYmIGV4cGVjdFNjcm9sbDtcblxuICAgIGlmIChzdXBwb3J0c1Njcm9sbCkge1xuICAgICAgc2V0dXBTY3JvbGwoKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihzdXBwb3J0c1B1c2hTdGF0ZSA/ICdwb3BzdGF0ZScgOiAnaGFzaGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcyQxLmN1cnJlbnQ7XG4gICAgICBpZiAoIWVuc3VyZVNsYXNoKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGdldEhhc2goKSwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Njcm9sbCkge1xuICAgICAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdXBwb3J0c1B1c2hTdGF0ZSkge1xuICAgICAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHB1c2hIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudC5mdWxsUGF0aDtcbiAgICBpZiAoZ2V0SGFzaCgpICE9PSBjdXJyZW50KSB7XG4gICAgICBwdXNoID8gcHVzaEhhc2goY3VycmVudCkgOiByZXBsYWNlSGFzaChjdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEhhc2goKVxuICB9O1xuXG4gIHJldHVybiBIYXNoSGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG5mdW5jdGlvbiBjaGVja0ZhbGxiYWNrIChiYXNlKSB7XG4gIHZhciBsb2NhdGlvbiA9IGdldExvY2F0aW9uKGJhc2UpO1xuICBpZiAoIS9eXFwvIy8udGVzdChsb2NhdGlvbikpIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShcbiAgICAgIGNsZWFuUGF0aChiYXNlICsgJy8jJyArIGxvY2F0aW9uKVxuICAgICk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVTbGFzaCAoKSB7XG4gIHZhciBwYXRoID0gZ2V0SGFzaCgpO1xuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmVwbGFjZUhhc2goJy8nICsgcGF0aCk7XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZXRIYXNoICgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zbGljZShpbmRleCArIDEpXG59XG5cbmZ1bmN0aW9uIGdldFVybCAocGF0aCkge1xuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaSA9IGhyZWYuaW5kZXhPZignIycpO1xuICB2YXIgYmFzZSA9IGkgPj0gMCA/IGhyZWYuc2xpY2UoMCwgaSkgOiBocmVmO1xuICByZXR1cm4gKGJhc2UgKyBcIiNcIiArIHBhdGgpXG59XG5cbmZ1bmN0aW9uIHB1c2hIYXNoIChwYXRoKSB7XG4gIGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuICAgIHB1c2hTdGF0ZShnZXRVcmwocGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaCAocGF0aCkge1xuICBpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcbiAgICByZXBsYWNlU3RhdGUoZ2V0VXJsKHBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShnZXRVcmwocGF0aCkpO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBBYnN0cmFjdEhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gQWJzdHJhY3RIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy5pbmRleCA9IC0xO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgQWJzdHJhY3RIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBYnN0cmFjdEhpc3Rvcnk7XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXggKyAxKS5jb25jYXQocm91dGUpO1xuICAgICAgdGhpcyQxLmluZGV4Kys7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4KS5jb25jYXQocm91dGUpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB0YXJnZXRJbmRleCA9IHRoaXMuaW5kZXggKyBuO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgcm91dGUgPSB0aGlzLnN0YWNrW3RhcmdldEluZGV4XTtcbiAgICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEuaW5kZXggPSB0YXJnZXRJbmRleDtcbiAgICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBjdXJyZW50ID8gY3VycmVudC5mdWxsUGF0aCA6ICcvJ1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMICgpIHtcbiAgICAvLyBub29wXG4gIH07XG5cbiAgcmV0dXJuIEFic3RyYWN0SGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG4vKiAgKi9cblxudmFyIFZ1ZVJvdXRlciA9IGZ1bmN0aW9uIFZ1ZVJvdXRlciAob3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICB0aGlzLmFwcCA9IG51bGw7XG4gIHRoaXMuYXBwcyA9IFtdO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmJlZm9yZUhvb2tzID0gW107XG4gIHRoaXMucmVzb2x2ZUhvb2tzID0gW107XG4gIHRoaXMuYWZ0ZXJIb29rcyA9IFtdO1xuICB0aGlzLm1hdGNoZXIgPSBjcmVhdGVNYXRjaGVyKG9wdGlvbnMucm91dGVzIHx8IFtdLCB0aGlzKTtcblxuICB2YXIgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCAnaGFzaCc7XG4gIHRoaXMuZmFsbGJhY2sgPSBtb2RlID09PSAnaGlzdG9yeScgJiYgIXN1cHBvcnRzUHVzaFN0YXRlICYmIG9wdGlvbnMuZmFsbGJhY2sgIT09IGZhbHNlO1xuICBpZiAodGhpcy5mYWxsYmFjaykge1xuICAgIG1vZGUgPSAnaGFzaCc7XG4gIH1cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICBtb2RlID0gJ2Fic3RyYWN0JztcbiAgfVxuICB0aGlzLm1vZGUgPSBtb2RlO1xuXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ2hpc3RvcnknOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhUTUw1SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIYXNoSGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UsIHRoaXMuZmFsbGJhY2spO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdhYnN0cmFjdCc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgQWJzdHJhY3RIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIChcImludmFsaWQgbW9kZTogXCIgKyBtb2RlKSk7XG4gICAgICB9XG4gIH1cbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGN1cnJlbnRSb3V0ZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2ggKFxuICByYXcsXG4gIGN1cnJlbnQsXG4gIHJlZGlyZWN0ZWRGcm9tXG4pIHtcbiAgcmV0dXJuIHRoaXMubWF0Y2hlci5tYXRjaChyYXcsIGN1cnJlbnQsIHJlZGlyZWN0ZWRGcm9tKVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmN1cnJlbnRSb3V0ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhpc3RvcnkgJiYgdGhpcy5oaXN0b3J5LmN1cnJlbnRcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKGFwcCAvKiBWdWUgY29tcG9uZW50IGluc3RhbmNlICovKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnQoXG4gICAgaW5zdGFsbC5pbnN0YWxsZWQsXG4gICAgXCJub3QgaW5zdGFsbGVkLiBNYWtlIHN1cmUgdG8gY2FsbCBgVnVlLnVzZShWdWVSb3V0ZXIpYCBcIiArXG4gICAgXCJiZWZvcmUgY3JlYXRpbmcgcm9vdCBpbnN0YW5jZS5cIlxuICApO1xuXG4gIHRoaXMuYXBwcy5wdXNoKGFwcCk7XG5cbiAgLy8gbWFpbiBhcHAgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgaWYgKHRoaXMuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmFwcCA9IGFwcDtcblxuICB2YXIgaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcblxuICBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhUTUw1SGlzdG9yeSkge1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9IGVsc2UgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIYXNoSGlzdG9yeSkge1xuICAgIHZhciBzZXR1cEhhc2hMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhpc3Rvcnkuc2V0dXBMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKFxuICAgICAgaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSxcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXJcbiAgICApO1xuICB9XG5cbiAgaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgdGhpcyQxLmFwcHMuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7XG4gICAgICBhcHAuX3JvdXRlID0gcm91dGU7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gYmVmb3JlRWFjaCAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmJlZm9yZUhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlUmVzb2x2ZSA9IGZ1bmN0aW9uIGJlZm9yZVJlc29sdmUgKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5yZXNvbHZlSG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiBhZnRlckVhY2ggKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5hZnRlckhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vblJlYWR5KGNiLCBlcnJvckNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uRXJyb3IoZXJyb3JDYik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucHVzaChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgdGhpcy5oaXN0b3J5LmdvKG4pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gYmFjayAoKSB7XG4gIHRoaXMuZ28oLTEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gZm9yd2FyZCAoKSB7XG4gIHRoaXMuZ28oMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdldE1hdGNoZWRDb21wb25lbnRzID0gZnVuY3Rpb24gZ2V0TWF0Y2hlZENvbXBvbmVudHMgKHRvKSB7XG4gIHZhciByb3V0ZSA9IHRvXG4gICAgPyB0by5tYXRjaGVkXG4gICAgICA/IHRvXG4gICAgICA6IHRoaXMucmVzb2x2ZSh0bykucm91dGVcbiAgICA6IHRoaXMuY3VycmVudFJvdXRlO1xuICBpZiAoIXJvdXRlKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgcm91dGUubWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG0uY29tcG9uZW50c1trZXldXG4gICAgfSlcbiAgfSkpXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChcbiAgdG8sXG4gIGN1cnJlbnQsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKFxuICAgIHRvLFxuICAgIGN1cnJlbnQgfHwgdGhpcy5oaXN0b3J5LmN1cnJlbnQsXG4gICAgYXBwZW5kLFxuICAgIHRoaXNcbiAgKTtcbiAgdmFyIHJvdXRlID0gdGhpcy5tYXRjaChsb2NhdGlvbiwgY3VycmVudCk7XG4gIHZhciBmdWxsUGF0aCA9IHJvdXRlLnJlZGlyZWN0ZWRGcm9tIHx8IHJvdXRlLmZ1bGxQYXRoO1xuICB2YXIgYmFzZSA9IHRoaXMuaGlzdG9yeS5iYXNlO1xuICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYoYmFzZSwgZnVsbFBhdGgsIHRoaXMubW9kZSk7XG4gIHJldHVybiB7XG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIHJvdXRlOiByb3V0ZSxcbiAgICBocmVmOiBocmVmLFxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgbm9ybWFsaXplZFRvOiBsb2NhdGlvbixcbiAgICByZXNvbHZlZDogcm91dGVcbiAgfVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZGRSb3V0ZXMgPSBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICB0aGlzLm1hdGNoZXIuYWRkUm91dGVzKHJvdXRlcyk7XG4gIGlmICh0aGlzLmhpc3RvcnkuY3VycmVudCAhPT0gU1RBUlQpIHtcbiAgICB0aGlzLmhpc3RvcnkudHJhbnNpdGlvblRvKHRoaXMuaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWdWVSb3V0ZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJIb29rIChsaXN0LCBmbikge1xuICBsaXN0LnB1c2goZm4pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gbGlzdC5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7IGxpc3Quc3BsaWNlKGksIDEpOyB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSHJlZiAoYmFzZSwgZnVsbFBhdGgsIG1vZGUpIHtcbiAgdmFyIHBhdGggPSBtb2RlID09PSAnaGFzaCcgPyAnIycgKyBmdWxsUGF0aCA6IGZ1bGxQYXRoO1xuICByZXR1cm4gYmFzZSA/IGNsZWFuUGF0aChiYXNlICsgJy8nICsgcGF0aCkgOiBwYXRoXG59XG5cblZ1ZVJvdXRlci5pbnN0YWxsID0gaW5zdGFsbDtcblZ1ZVJvdXRlci52ZXJzaW9uID0gJzMuMC4xJztcblxuaWYgKGluQnJvd3NlciAmJiB3aW5kb3cuVnVlKSB7XG4gIHdpbmRvdy5WdWUudXNlKFZ1ZVJvdXRlcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZVJvdXRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5lc20uanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNWVmNDg5NThcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vYXBwLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI2Mjk4MTQ3YVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNWVmNDg5NThcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vYXBwLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi01ZWY0ODk1OFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9hcHAudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTVlZjQ4OTU4XCIsXCJzY29wZWRcIjpmYWxzZSxcInNvdXJjZU1hcFwiOnRydWV9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvYXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi01ZWY0ODk1OFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJzb3VyY2VNYXBcIjp0cnVlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL2FwcC52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG5pbXBvcnQgbGlzdFRvU3R5bGVzIGZyb20gJy4vbGlzdFRvU3R5bGVzJ1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cbnZhciBvcHRpb25zID0gbnVsbFxudmFyIHNzcklkS2V5ID0gJ2RhdGEtdnVlLXNzci1pZCdcblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkU3R5bGVzQ2xpZW50IChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbiwgX29wdGlvbnMpIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIG9wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlWycgKyBzc3JJZEtleSArICd+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuICBpZiAob3B0aW9ucy5zc3JJZCkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoc3NySWRLZXksIG9iai5pZClcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChwYXJlbnRJZCwgbGlzdCkge1xuICB2YXIgc3R5bGVzID0gW11cbiAgdmFyIG5ld1N0eWxlcyA9IHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIHZhciBpZCA9IGl0ZW1bMF1cbiAgICB2YXIgY3NzID0gaXRlbVsxXVxuICAgIHZhciBtZWRpYSA9IGl0ZW1bMl1cbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXVxuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgaWQ6IHBhcmVudElkICsgJzonICsgaSxcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9XG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0geyBpZDogaWQsIHBhcnRzOiBbcGFydF0gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi41LjEzXG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUgZS5nLiBbb2JqZWN0IE9iamVjdF1cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICovXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm0gfHwge307XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlLCBkZWVwKSB7XG4gIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIGNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgaWYgKGRlZXApIHtcbiAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGNsb25lZC5jaGlsZHJlbiA9IGNsb25lVk5vZGVzKHZub2RlLmNoaWxkcmVuLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMgJiYgY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbikge1xuICAgICAgY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbiA9IGNsb25lVk5vZGVzKGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sIHRydWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMsIGRlZXApIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldLCBkZWVwKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXG4gKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG4gKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cbiAqL1xudmFyIG9ic2VydmVyU3RhdGUgPSB7XG4gIHNob3VsZENvbnZlcnQ6IHRydWVcbn07XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcbiAgICApO1xuICB9XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShwcm9wcykpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucywgdm0pIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluamVjdCkge1xuICAgICAgdmFyIHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAvLyBza2lwIHZhbGlkYXRpb24gZm9yIHdlZXggcmVjeWNsZS1saXN0IGNoaWxkIGNvbXBvbmVudCBwcm9wc1xuICAgICEoZmFsc2UgJiYgaXNPYmplY3QodmFsdWUpICYmICgnQGJpbmRpbmcnIGluIHZhbHVlKSlcbiAgKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcbiAgICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpICtcbiAgICAgIFwiLCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHZtKSB7XG4gICAgdmFyIGN1ciA9IHZtO1xuICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgIGlmIChob29rcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNZXNzYWdlQ2hhbm5lbCAqL1xuXG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBib3RoIG1pY3JvIGFuZCBtYWNybyB0YXNrcy5cbi8vIEluIDwgMi40IHdlIHVzZWQgbWljcm8gdGFza3MgZXZlcnl3aGVyZSwgYnV0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvcyB3aGVyZVxuLy8gbWljcm8gdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlcyBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCkgb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lXG4vLyBldmVudCAoIzY1NjYpLiBIb3dldmVyLCB1c2luZyBtYWNybyB0YXNrcyBldmVyeXdoZXJlIGFsc28gaGFzIHN1YnRsZSBwcm9ibGVtc1xuLy8gd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50IChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxuLy8gSGVyZSB3ZSB1c2UgbWljcm8gdGFzayBieSBkZWZhdWx0LCBidXQgZXhwb3NlIGEgd2F5IHRvIGZvcmNlIG1hY3JvIHRhc2sgd2hlblxuLy8gbmVlZGVkIChlLmcuIGluIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIGJ5IHYtb24pLlxudmFyIG1pY3JvVGltZXJGdW5jO1xudmFyIG1hY3JvVGltZXJGdW5jO1xudmFyIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuXG4vLyBEZXRlcm1pbmUgKG1hY3JvKSBUYXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLy8gVGVjaG5pY2FsbHkgc2V0SW1tZWRpYXRlIHNob3VsZCBiZSB0aGUgaWRlYWwgY2hvaWNlLCBidXQgaXQncyBvbmx5IGF2YWlsYWJsZVxuLy8gaW4gSUUuIFRoZSBvbmx5IHBvbHlmaWxsIHRoYXQgY29uc2lzdGVudGx5IHF1ZXVlcyB0aGUgY2FsbGJhY2sgYWZ0ZXIgYWxsIERPTVxuLy8gZXZlbnRzIHRyaWdnZXJlZCBpbiB0aGUgc2FtZSBsb29wIGlzIGJ5IHVzaW5nIE1lc3NhZ2VDaGFubmVsLlxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnICYmIChcbiAgaXNOYXRpdmUoTWVzc2FnZUNoYW5uZWwpIHx8XG4gIC8vIFBoYW50b21KU1xuICBNZXNzYWdlQ2hhbm5lbC50b1N0cmluZygpID09PSAnW29iamVjdCBNZXNzYWdlQ2hhbm5lbENvbnN0cnVjdG9yXSdcbikpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoQ2FsbGJhY2tzO1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwb3J0LnBvc3RNZXNzYWdlKDEpO1xuICB9O1xufSBlbHNlIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbi8vIERldGVybWluZSBNaWNyb1Rhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIG1pY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gZmFsbGJhY2sgdG8gbWFjcm9cbiAgbWljcm9UaW1lckZ1bmMgPSBtYWNyb1RpbWVyRnVuYztcbn1cblxuLyoqXG4gKiBXcmFwIGEgZnVuY3Rpb24gc28gdGhhdCBpZiBhbnkgY29kZSBpbnNpZGUgdHJpZ2dlcnMgc3RhdGUgY2hhbmdlLFxuICogdGhlIGNoYW5nZXMgYXJlIHF1ZXVlZCB1c2luZyBhIFRhc2sgaW5zdGVhZCBvZiBhIE1pY3JvVGFzay5cbiAqL1xuZnVuY3Rpb24gd2l0aE1hY3JvVGFzayAoZm4pIHtcbiAgcmV0dXJuIGZuLl93aXRoVGFzayB8fCAoZm4uX3dpdGhUYXNrID0gZnVuY3Rpb24gKCkge1xuICAgIHVzZU1hY3JvVGFzayA9IHRydWU7XG4gICAgdmFyIHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgdXNlTWFjcm9UYXNrID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlc1xuICB9KVxufVxuXG5mdW5jdGlvbiBuZXh0VGljayAoY2IsIGN0eCkge1xuICB2YXIgX3Jlc29sdmU7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZShjdHgpO1xuICAgIH1cbiAgfSk7XG4gIGlmICghcGVuZGluZykge1xuICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgIGlmICh1c2VNYWNyb1Rhc2spIHtcbiAgICAgIG1hY3JvVGltZXJGdW5jKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pY3JvVGltZXJGdW5jKCk7XG4gICAgfVxuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xvbmVkW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgZGVmLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSkge1xuICBpZiAob25jZSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKCFmbikge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmIChmbikge1xuICAgICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgICAgdmFyIGNiO1xuICAgICAgdmFyIGkkMSA9IGNicy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaSQxLS0pIHtcbiAgICAgICAgY2IgPSBjYnNbaSQxXTtcbiAgICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgICBjYnMuc3BsaWNlKGkkMSwgMSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgICAvLyBubyBuZWVkIGZvciB0aGUgcmVmIG5vZGVzIGFmdGVyIGluaXRpYWwgcGF0Y2hcbiAgICAgIC8vIHRoaXMgcHJldmVudHMga2VlcGluZyBhIGRldGFjaGVkIERPTSB0cmVlIGluIG1lbW9yeSAoIzU4NTEpXG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCBudWxsLCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gKHBhcmVudFZub2RlLmRhdGEgJiYgcGFyZW50Vm5vZGUuZGF0YS5hdHRycykgfHwgZW1wdHlPYmplY3Q7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBoeXBoZW5hdGVkS2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiB1c2VyRGVmO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAga2V5T3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goa2V5T3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5qZWN0LCBrZXkpLmVudW1lcmFibGVcbiAgICAgIH0pXG4gICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHByb3ZpZGVEZWZhdWx0LmNhbGwodm0pXG4gICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgfVxuICB9XG4gIGlmIChpc0RlZihyZXQpKSB7XG4gICAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2Rlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdE5vZGVzLl9yZW5kZXJlZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZXMgPSBzbG90Tm9kZXMgfHwgZmFsbGJhY2s7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xuICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzLFxuICBldmVudEtleU5hbWVcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChrZXlDb2Rlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgICAgcmV0dXJuIGtleUNvZGVzLmluZGV4T2YoZXZlbnRLZXlDb2RlKSA9PT0gLTFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodHJlZSlcbiAgICAgID8gY2xvbmVWTm9kZXModHJlZSlcbiAgICAgIDogY2xvbmVWTm9kZSh0cmVlKVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudCk7IH07XG5cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IGRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICB2bm9kZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gICAgdm5vZGUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cblxuLy8gUmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBob29rIHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXG4vLyBUaGUgaG9vayB3aWxsIGJlIHRyaWdnZXJlZCBieSBuYXRpdmUsIG5vdCBqYXZhc2NyaXB0LlxuXG5cbi8vIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBjb21wb25lbnQgdG8gd2VleCBuYXRpdmUgcmVuZGVyIGVuZ2luZS5cblxuLyogICovXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYW5rczEwMTAwL3dlZXgtbmF0aXZlLWRpcmVjdGl2ZS90cmVlL21hc3Rlci9jb21wb25lbnRcblxuLy8gbGlzdGVuaW5nIG9uIG5hdGl2ZSBjYWxsYmFja1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IsIGNvbnRleHQpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIG1lcmdlIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgbWVyZ2VIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9LFxuICAgIGFzeW5jRmFjdG9yeVxuICApO1xuXG4gIC8vIFdlZXggc3BlY2lmaWM6IGludm9rZSByZWN5Y2xlLWxpc3Qgb3B0aW1pemVkIEByZW5kZXIgZnVuY3Rpb24gZm9yXG4gIC8vIGV4dHJhY3RpbmcgY2VsbC1zbG90IHRlbXBsYXRlLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vSGFua3MxMDEwMC93ZWV4LW5hdGl2ZS1kaXJlY3RpdmUvdHJlZS9tYXN0ZXIvY29tcG9uZW50XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgcGFyZW50RWxtLFxuICByZWZFbG1cbikge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChpc0RlZihvbltldmVudF0pKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICB0YWcgPSBkYXRhLmlzO1xuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChucykgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICBucyA9IHVuZGVmaW5lZDtcbiAgICBmb3JjZSA9IHRydWU7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChpc1VuZGVmKGNoaWxkLm5zKSB8fCBpc1RydWUoZm9yY2UpKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIC8vIGlmIHRoZSBwYXJlbnQgZGlkbid0IHVwZGF0ZSwgdGhlIHNsb3Qgbm9kZXMgd2lsbCBiZSB0aGUgb25lcyBmcm9tXG4gICAgICAvLyBsYXN0IHJlbmRlci4gVGhleSBuZWVkIHRvIGJlIGNsb25lZCB0byBlbnN1cmUgXCJmcmVzaG5lc3NcIiBmb3IgdGhpcyByZW5kZXIuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XG4gICAgICAgIHZhciBzbG90ID0gdm0uJHNsb3RzW2tleV07XG4gICAgICAgIC8vIF9yZW5kZXJlZCBpcyBhIGZsYWcgYWRkZWQgYnkgcmVuZGVyU2xvdCwgYnV0IG1heSBub3QgYmUgcHJlc2VudFxuICAgICAgICAvLyBpZiB0aGUgc2xvdCBpcyBwYXNzZWQgZnJvbSBtYW51YWxseSB3cml0dGVuIHJlbmRlciBmdW5jdGlvbnNcbiAgICAgICAgaWYgKHNsb3QuX3JlbmRlcmVkIHx8IChzbG90WzBdICYmIHNsb3RbMF0uZWxtKSkge1xuICAgICAgICAgIHZtLiRzbG90c1trZXldID0gY2xvbmVWTm9kZXMoc2xvdCwgdHJ1ZSAvKiBkZWVwICovKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZtLiRzY29wZWRTbG90cyA9IChfcGFyZW50Vm5vZGUgJiYgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMpIHx8IGVtcHR5T2JqZWN0O1xuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQkMSA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDErKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG5cbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgZXh0ZW5kZWQgPSBDdG9yLmV4dGVuZE9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIGV4dGVuZGVkW2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBleHRlbmRlZCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZXh0ZW5kZWQgPSBBcnJheS5pc0FycmF5KGV4dGVuZGVkKSA/IGV4dGVuZGVkIDogW2V4dGVuZGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcbiAgICAgIGlmIChleHRlbmRlZC5pbmRleE9mKGxhdGVzdFtpXSkgPj0gMCB8fCBzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xuICB2YXIgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlO1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIHZhciBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xuICBpZiAoY2FjaGVkJCQxICYmICghY3VycmVudCB8fCBjYWNoZWQkJDEudGFnICE9PSBjdXJyZW50LnRhZykpIHtcbiAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZVtrZXldID0gbnVsbDtcbiAgcmVtb3ZlKGtleXMsIGtleSk7XG59XG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZSwga2V5LCB0aGlzJDEua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0sXG4gICAgZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgaW5jbHVkZSA9IHJlZi5pbmNsdWRlO1xuICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xuICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuNS4xMyc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIHN0cmluZ2lmaWVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWtleSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKHJlZiQkMS5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodm5vZGUudGV4dCkpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmZuU2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgIGkgIT09IHZub2RlLmZuQ29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICB2YXIgc2VlbktleXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcbiAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xuICAgIHZub2RlLmVsbSA9IGVsbTtcblxuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gYXNzZXJ0IG5vZGUgbWF0Y2hcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB2YXIgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgIHZhciBpbnNlcnQgPSBhbmNlc3Rvci5kYXRhLmhvb2suaW5zZXJ0O1xuICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGF0IGluZGV4IDEgdG8gYXZvaWQgcmUtaW52b2tpbmcgY29tcG9uZW50IG1vdW50ZWQgaG9va1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDE7IGkkMiA8IGluc2VydC5mbnMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0LmZuc1tpJDJdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0kMSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxuICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcbiAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgID8gJ3RydWUnXG4gICAgICAgIDoga2V5O1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoXG4gICAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmICFlbC5fX2llcGhcbiAgICAgICkge1xuICAgICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgICB9O1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgICAgfVxuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgdmFyIGluRG91YmxlID0gZmFsc2U7XG4gIHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gIHZhciBjdXJseSA9IDA7XG4gIHZhciBzcXVhcmUgPSAwO1xuICB2YXIgcGFyZW4gPSAwO1xuICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgdmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIHsgaW5TaW5nbGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIHsgaW5SZWdleCA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIsXCIgKyBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnKSB7XG4gIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG59XG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG4vLyBhZGQgYSByYXcgYXR0ciAodXNlIHRoaXMgaW4gcHJlVHJhbnNmb3JtcylcbmZ1bmN0aW9uIGFkZFJhd0F0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuXG4pIHtcbiAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4gJiZcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJ1xuICAgICk7XG4gIH1cblxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSAnJicgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBwYXNzaXZlXG4gIH1cblxuICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcbiAgLy8gdGhpcyBpcyB0ZWNobmljYWxseSBicm93c2VyLXNwZWNpZmljLCBidXQgYXQgbGVhc3QgZm9yIG5vdyBicm93c2VycyBhcmVcbiAgLy8gdGhlIG9ubHkgdGFyZ2V0IGVudnMgdGhhdCBoYXZlIHJpZ2h0L21pZGRsZSBjbGlja3MuXG4gIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAobW9kaWZpZXJzLm1pZGRsZSkge1xuICAgICAgbmFtZSA9ICdtb3VzZXVwJztcbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG5cbiAgdmFyIG5ld0hhbmRsZXIgPSB7IHZhbHVlOiB2YWx1ZSB9O1xuICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG5cbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmVtb3ZlRnJvbU1hcFxuKSB7XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlRnJvbU1hcCkge1xuICAgIGRlbGV0ZSBlbC5hdHRyc01hcFtuYW1lXTtcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICBpZiAoaW5kZXgkMSA+IC0xKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4JDEgKyAxKSArICdcIidcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwsXG4gICAgICAgIGtleTogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0ciA9IHZhbDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXG4gICAga2V5OiB2YWwuc2xpY2UoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLFxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIHZhbHVlICsgXCI9JCRhLmNvbmNhdChbJCR2XSkpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIHZhbHVlICsgXCI9JCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSkpfVwiICtcbiAgICBcIn1lbHNle1wiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJykpICsgXCJ9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB2YWx1ZSQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddIHx8IGVsLmF0dHJzTWFwWyc6dmFsdWUnXTtcbiAgICBpZiAodmFsdWUkMSkge1xuICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgd2FybiQxKFxuICAgICAgICBiaW5kaW5nICsgXCI9XFxcIlwiICsgdmFsdWUkMSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgXCIgK1xuICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseSdcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUkMihldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlJCQxLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgaGFuZGxlciA9IHdpdGhNYWNyb1Rhc2soaGFuZGxlcik7XG4gIGlmIChvbmNlJCQxKSB7IGhhbmRsZXIgPSBjcmVhdGVPbmNlSGFuZGxlcihoYW5kbGVyLCBldmVudCwgY2FwdHVyZSk7IH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLl93aXRoVGFzayB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxuICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgIGlmIChtb2RpZmllcnMubGF6eSkge1xuICAgICAgLy8gaW5wdXRzIHdpdGggbGF6eSBzaG91bGQgb25seSBiZSB1cGRhdGVkIHdoZW4gbm90IGluIGZvY3VzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmKSB7XG4gIGlmICghZGVmKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZik7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZilcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICA6IHNldFRpbWVvdXRcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgZGlyZWN0aXZlID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgaWYgKCFpc0FuZHJvaWQpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblZ1ZSQzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSQzKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNDaHJvbWUpIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICBpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgKTtcbiAgfVxufSwgMCk7XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cblxuXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxuICB0ZXh0LFxuICBkZWxpbWl0ZXJzXG4pIHtcbiAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHJhd1Rva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleCwgdG9rZW5WYWx1ZTtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgpKTtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBleHByZXNzaW9uOiB0b2tlbnMuam9pbignKycpLFxuICAgIHRva2VuczogcmF3VG9rZW5zXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vKiFcbiAqIEhUTUwgUGFyc2VyIEJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcbiAqIE1vZGlmaWVkIGJ5IEp1cml5IFwia2FuZ2F4XCIgWmF5dHNldlxuICogT3JpZ2luYWwgY29kZSBieSBFcmlrIEFydmlkc3NvbiwgTW96aWxsYSBQdWJsaWMgTGljZW5zZVxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/Lztcbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbnZhciBjb21tZW50ID0gL148IS0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxudmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG59KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCdcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShsYXN0VGFnLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCEtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcbiAgICAgIGlmIChJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOICYmIGFyZ3NbMF0uaW5kZXhPZignXCJcIicpID09PSAtMSkge1xuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cbiAgICAgICAgaWYgKGFyZ3NbNF0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzRdOyB9XG4gICAgICAgIGlmIChhcmdzWzVdID09PSAnJykgeyBkZWxldGUgYXJnc1s1XTsgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSB0YWdOYW1lID09PSAnYScgJiYgYXJnc1sxXSA9PT0gJ2hyZWYnXG4gICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcbiAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oLio/KVxccysoPzppbnxvZilcXHMrKC4qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbnZhciBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxuICB0YWcsXG4gIGF0dHJzLFxuICBwYXJlbnRcbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDEsXG4gICAgdGFnOiB0YWcsXG4gICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcblxuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VFbGVtZW50IChlbGVtZW50KSB7XG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICBzaG91bGRLZWVwQ29tbWVudDogb3B0aW9ucy5jb21tZW50cyxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5KSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgLy8gZWxlbWVudC1zY29wZSBzdHVmZlxuICAgICAgICBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGFzdE5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2VsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gMyAmJiBsYXN0Tm9kZS50ZXh0ID09PSAnICcgJiYgIWluUHJlKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIHRleHQgPSBpblByZSB8fCB0ZXh0LnRyaW0oKVxuICAgICAgICA/IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXG4gICAgICAgIC8vIG9ubHkgcHJlc2VydmUgd2hpdGVzcGFjZSBpZiBpdHMgbm90IHJpZ2h0IGFmdGVyIGEgc3RhcnRpbmcgdGFnXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0KSB7XG4gICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goe1xuICAgICAgICB0eXBlOiAzLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcbiAgaWYgKGwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9ICFlbGVtZW50LmtleSAmJiAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoO1xuXG4gIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm4kMihcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgZXh0ZW5kKGVsLCByZXMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xuICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgaWYgKCFpbk1hdGNoKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgcmVzLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKTtcbiAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcy5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKTtcbiAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCJcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3RTY29wZTtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdFNjb3BlKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xuICAgICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcbiAgICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJyk7XG4gICAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwiQW1iaWd1b3VzIGNvbWJpbmVkIHVzYWdlIG9mIHNsb3Qtc2NvcGUgYW5kIHYtZm9yIG9uIDxcIiArIChlbC50YWcpICsgXCI+IFwiICtcbiAgICAgICAgICBcIih2LWZvciB0YWtlcyBoaWdoZXIgcHJpb3JpdHkpLiBVc2UgYSB3cmFwcGVyIDx0ZW1wbGF0ZT4gZm9yIHRoZSBcIiArXG4gICAgICAgICAgXCJzY29wZWQgc2xvdCB0byBtYWtlIGl0IGNsZWFyZXIuXCIsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICAgIH1cbiAgICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICAgIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XG4gICAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxuICAgICAgaWYgKGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGlzUHJvcDtcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3ApIHtcbiAgICAgICAgICAgIGlzUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvcCB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUpO1xuICAgIH1cbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbi8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xuICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSdcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogRXhwYW5kIGlucHV0W3YtbW9kZWxdIHdpdGggZHlhbm1pYyB0eXBlIGJpbmRpbmdzIGludG8gdi1pZi1lbHNlIGNoYWluc1xuICogVHVybiB0aGlzOlxuICogICA8aW5wdXQgdi1tb2RlbD1cImRhdGFbdHlwZV1cIiA6dHlwZT1cInR5cGVcIj5cbiAqIGludG8gdGhpczpcbiAqICAgPGlucHV0IHYtaWY9XCJ0eXBlID09PSAnY2hlY2tib3gnXCIgdHlwZT1cImNoZWNrYm94XCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqICAgPGlucHV0IHYtZWxzZS1pZj1cInR5cGUgPT09ICdyYWRpbydcIiB0eXBlPVwicmFkaW9cIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICogICA8aW5wdXQgdi1lbHNlIDp0eXBlPVwidHlwZVwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKi9cblxuZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICBpZiAobWFwWyd2LW1vZGVsJ10gJiYgKG1hcFsndi1iaW5kOnR5cGUnXSB8fCBtYXBbJzp0eXBlJ10pKSB7XG4gICAgICB2YXIgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICAgIHZhciBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XG4gICAgICB2YXIgaWZDb25kaXRpb25FeHRyYSA9IGlmQ29uZGl0aW9uID8gKFwiJiYoXCIgKyBpZkNvbmRpdGlvbiArIFwiKVwiKSA6IFwiXCI7XG4gICAgICB2YXIgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xuICAgICAgdmFyIGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcbiAgICAgIC8vIDEuIGNoZWNrYm94XG4gICAgICB2YXIgYnJhbmNoMCA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAvLyBwcm9jZXNzIGZvciBvbiB0aGUgbWFpbiBub2RlXG4gICAgICBwcm9jZXNzRm9yKGJyYW5jaDApO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gwLCAndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMCwgb3B0aW9ucyk7XG4gICAgICBicmFuY2gwLnByb2Nlc3NlZCA9IHRydWU7IC8vIHByZXZlbnQgaXQgZnJvbSBkb3VibGUtcHJvY2Vzc2VkXG4gICAgICBicmFuY2gwLmlmID0gXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdjaGVja2JveCdcIiArIGlmQ29uZGl0aW9uRXh0cmE7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogYnJhbmNoMC5pZixcbiAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgIH0pO1xuICAgICAgLy8gMi4gYWRkIHJhZGlvIGVsc2UtaWYgY29uZGl0aW9uXG4gICAgICB2YXIgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDEsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gxLCAndHlwZScsICdyYWRpbycpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdyYWRpbydcIiArIGlmQ29uZGl0aW9uRXh0cmEsXG4gICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICB9KTtcbiAgICAgIC8vIDMuIG90aGVyXG4gICAgICB2YXIgYnJhbmNoMiA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDIsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gyLCAnOnR5cGUnLCB0eXBlQmluZGluZyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gyLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBpZkNvbmRpdGlvbixcbiAgICAgICAgYmxvY2s6IGJyYW5jaDJcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzRWxzZSkge1xuICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbHNlSWZDb25kaXRpb24pIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlaWYgPSBlbHNlSWZDb25kaXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicmFuY2gwXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lQVNURWxlbWVudCAoZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUFTVEVsZW1lbnQoZWwudGFnLCBlbC5hdHRyc0xpc3Quc2xpY2UoKSwgZWwucGFyZW50KVxufVxuXG52YXIgbW9kZWwkMiA9IHtcbiAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMSxcbiAgbW9kZWwkMlxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbi8qICAqL1xuXG52YXIgaXNTdGF0aWNLZXk7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycycgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15cXHMqW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnLio/J118XFxbXCIuKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSpcXHMqJC87XG5cbi8vIGtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlLFxuICB3YXJuXG4pIHtcbiAgdmFyIHJlcyA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBldmVudHNbbmFtZV0pKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxuICBuYW1lLFxuICBoYW5kbGVyXG4pIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci52YWx1ZVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdleGFjdCcpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcbiAgICAgICAgICBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNba2V5TW9kaWZpZXJdOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuIChcIiRldmVudC5cIiArIGtleU1vZGlmaWVyICsgXCJLZXlcIik7IH0pXG4gICAgICAgICAgICAuam9pbignfHwnKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyBoYW5kbGVyLnZhbHVlICsgJygkZXZlbnQpJ1xuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IChcIihcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFwiaWYoISgnYnV0dG9uJyBpbiAkZXZlbnQpJiZcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGNvZGUgPSBrZXlDb2Rlc1trZXldO1xuICByZXR1cm4gKFxuICAgIFwiX2soJGV2ZW50LmtleUNvZGUsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoY29kZSkpICsgXCIsXCIgK1xuICAgIFwiJGV2ZW50LmtleSlcIlxuICApXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkaXIubW9kaWZpZXJzKSB7XG4gICAgd2FybihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XG4gIH1cbiAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJfZyhcIiArIGNvZGUgKyBcIixcIiArIChkaXIudmFsdWUpICsgXCIpXCIpOyB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIFwiLFwiICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJykgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnN5bmMgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gIG9uOiBvbixcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cbnZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHRoaXMubWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XG4gIHRoaXMub25jZUlkID0gMDtcbiAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbn07XG5cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGEgPSBlbC5wbGFpbiA/IHVuZGVmaW5lZCA6IGdlbkRhdGEkMihlbCwgc3RhdGUpO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9XG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyBcIixcIiArIGtleSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gIGNvbmRpdGlvbnMsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgfVxuXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGFsdEdlblxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgOiBlbC5vbmNlXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEhlbHBlclxuKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgIWVsLmtleVxuICApIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybignSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyAoT2JqZWN0LmtleXMoc2xvdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0sIHN0YXRlKVxuICAgIH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxuICBrZXksXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3JTY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKVxuICB9XG4gIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLnNsb3RTY29wZSkpICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZWwuaWZcbiAgICAgICAgPyAoKGVsLmlmKSArIFwiP1wiICsgKGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCcpICsgXCI6dW5kZWZpbmVkXCIpXG4gICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCI7XG4gIHJldHVybiAoXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46XCIgKyBmbiArIFwifVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Gb3JTY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5TY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICBlbCxcbiAgc3RhdGUsXG4gIGNoZWNrU2tpcCxcbiAgYWx0R2VuRWxlbWVudCxcbiAgYWx0R2VuTm9kZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbCQxLmZvciAmJlxuICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIHJldHVybiAoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCQxLCBzdGF0ZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgIDogMDtcbiAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW4oYywgc3RhdGUpOyB9KS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XG4gICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9yc1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIGVycm9ycykge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgaWRlbnQsXG4gIHR5cGUsXG4gIHRleHQsXG4gIGVycm9yc1xuKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbigoXCJ2YXIgXCIgKyBpZGVudCArIFwiPV9cIikpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xuICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgdmFyIHdhcm4kJDEgPSBvcHRpb25zLndhcm4gfHwgd2FybjtcbiAgICBkZWxldGUgb3B0aW9ucy53YXJuO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKVxuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yIChiYXNlQ29tcGlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHZhciB0aXBzID0gW107XG4gICAgICBmaW5hbE9wdGlvbnMud2FybiA9IGZ1bmN0aW9uIChtc2csIHRpcCkge1xuICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID1cbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMgfHwgbnVsbCksXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLCBmaW5hbE9wdGlvbnMpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0KSk7XG4gICAgICB9XG4gICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICAgIHJldHVybiBjb21waWxlZFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlOiBjb21waWxlLFxuICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBgY3JlYXRlQ29tcGlsZXJDcmVhdG9yYCBhbGxvd3MgY3JlYXRpbmcgY29tcGlsZXJzIHRoYXQgdXNlIGFsdGVybmF0aXZlXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4vLyBIZXJlIHdlIGp1c3QgZXhwb3J0IGEgZGVmYXVsdCBjb21waWxlciB1c2luZyB0aGUgZGVmYXVsdCBwYXJ0cy5cbnZhciBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLm9wdGltaXplICE9PSBmYWxzZSkge1xuICAgIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIH1cbiAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGFzdDogYXN0LFxuICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59KTtcblxuLyogICovXG5cbnZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbi8qICAqL1xuXG4vLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xudmFyIGRpdjtcbmZ1bmN0aW9uIGdldFNob3VsZERlY29kZSAoaHJlZikge1xuICBkaXYgPSBkaXYgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBocmVmID8gXCI8YSBocmVmPVxcXCJcXG5cXFwiLz5cIiA6IFwiPGRpdiBhPVxcXCJcXG5cXFwiLz5cIjtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZignJiMxMDsnKSA+IDBcbn1cblxuLy8gIzM2NjM6IElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcbnZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZShmYWxzZSkgOiBmYWxzZTtcbi8vICM2ODI4OiBjaHJvbWUgZW5jb2RlcyBjb250ZW50IGluIGFbaHJlZl1cbnZhciBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUodHJ1ZSkgOiBmYWxzZTtcblxuLyogICovXG5cbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxufSk7XG5cbnZhciBtb3VudCA9IFZ1ZSQzLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlJDMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlJDM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcyIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKGNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTVlZjQ4OTU4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2FwcC52dWVcIilcbn1cbi8qIHNjcmlwdCAqL1xuZXhwb3J0ICogZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vYXBwLnZ1ZVwiXG5pbXBvcnQgX192dWVfc2NyaXB0X18gZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vYXBwLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSAqL1xuaW1wb3J0IHtyZW5kZXIgYXMgX192dWVfcmVuZGVyX18sIHN0YXRpY1JlbmRlckZucyBhcyBfX3Z1ZV9zdGF0aWNfcmVuZGVyX2Zuc19ffSBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi01ZWY0ODk1OFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2FwcC52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbmltcG9ydCBub3JtYWxpemVDb21wb25lbnQgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnQtbm9ybWFsaXplclwiXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfcmVuZGVyX18sXG4gIF9fdnVlX3N0YXRpY19yZW5kZXJfZm5zX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvYXBwLnZ1ZVwiXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi01ZWY0ODk1OFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTVlZjQ4OTU4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC52dWVcbi8vIG1vZHVsZSBpZCA9IC4vc3JjL2FwcC52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IFZ1ZVJvdXRlciBmcm9tICd2dWUtcm91dGVyJztcblxuaW1wb3J0IHJvdXRlcyBmcm9tICcuL3JvdXRlcyc7XG5pbXBvcnQgQXBwIGZyb20gJy4vYXBwJztcblxuVnVlLnVzZShWdWVSb3V0ZXIpO1xuXG5jb25zdCBSb3V0ZXJDb25maWcgPSB7XG4gICAgcm91dGVzOiByb3V0ZXNcbn1cbmNvbnN0IHJvdXRlciA9IG5ldyBWdWVSb3V0ZXIoUm91dGVyQ29uZmlnKTtcblxubmV3IFZ1ZSh7XG4gICAgZWw6ICcjcm9vdCcsXG4gICAgcm91dGVyOiByb3V0ZXIsXG4gICAgcmVuZGVyOiBoID0+IGgoQXBwKVxufSlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWFpbi5qcyIsImltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCBWdWVSb3V0ZXIgZnJvbSAndnVlLXJvdXRlcic7XG5cbmltcG9ydCByb3V0ZXMgZnJvbSAnLi9yb3V0ZXMnO1xuaW1wb3J0IEFwcCBmcm9tICcuL2FwcCc7XG5cblZ1ZS51c2UoVnVlUm91dGVyKTtcblxuY29uc3QgUm91dGVyQ29uZmlnID0ge1xuICAgIHJvdXRlczogcm91dGVzXG59XG5jb25zdCByb3V0ZXIgPSBuZXcgVnVlUm91dGVyKFJvdXRlckNvbmZpZyk7XG5cbm5ldyBWdWUoe1xuICAgIGVsOiAnI3Jvb3QnLFxuICAgIHJvdXRlcjogcm91dGVyLFxuICAgIHJlbmRlcjogaCA9PiBoKEFwcClcbn0pXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JvdXRlcy5qcyJdLCJzb3VyY2VSb290IjoiIn0=